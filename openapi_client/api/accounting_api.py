# coding: utf-8

"""
    Accounting API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 2.0.0
    Contact: api@xero.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (
    ApiTypeError,
    ApiValueError
)


class AccountingApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_account(self, account, **kwargs):  # noqa: E501
        """Allows you to create a new chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_account(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Account account: Request of type Account (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Accounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_account_with_http_info(account, **kwargs)  # noqa: E501

    def create_account_with_http_info(self, account, **kwargs):  # noqa: E501
        """Allows you to create a new chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_account_with_http_info(account, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Account account: Request of type Account (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account' is set
        if ('account' not in local_var_params or
                local_var_params['account'] is None):
            raise ApiValueError("Missing the required parameter `account` when calling `create_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'account' in local_var_params:
            body_params = local_var_params['account']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Accounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_account_attachment_by_file_name(self, account_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create Attachment on Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_account_attachment_by_file_name(account_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str file_name: Name of the attachment (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_account_attachment_by_file_name_with_http_info(account_id, file_name, body, **kwargs)  # noqa: E501

    def create_account_attachment_by_file_name_with_http_info(self, account_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create Attachment on Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_account_attachment_by_file_name_with_http_info(account_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str file_name: Name of the attachment (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_account_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `create_account_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_account_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_account_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bank_transaction(self, bank_transactions, **kwargs):  # noqa: E501
        """Allows you to create a spend or receive money transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transaction(bank_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BankTransactions bank_transactions: (required)
        :param bool summarize_errors: response format that shows validation errors for each bank transaction
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bank_transaction_with_http_info(bank_transactions, **kwargs)  # noqa: E501

    def create_bank_transaction_with_http_info(self, bank_transactions, **kwargs):  # noqa: E501
        """Allows you to create a spend or receive money transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transaction_with_http_info(bank_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BankTransactions bank_transactions: (required)
        :param bool summarize_errors: response format that shows validation errors for each bank transaction
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transactions', 'summarize_errors']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transactions' is set
        if ('bank_transactions' not in local_var_params or
                local_var_params['bank_transactions'] is None):
            raise ApiValueError("Missing the required parameter `bank_transactions` when calling `create_bank_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'summarize_errors' in local_var_params:
            query_params.append(('SummarizeErrors', local_var_params['summarize_errors']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bank_transactions' in local_var_params:
            body_params = local_var_params['bank_transactions']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bank_transaction_attachment_by_file_name(self, bank_transaction_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to createa an Attachment on BankTransaction by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transaction_attachment_by_file_name(bank_transaction_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str file_name: The name of the file being attached (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bank_transaction_attachment_by_file_name_with_http_info(bank_transaction_id, file_name, body, **kwargs)  # noqa: E501

    def create_bank_transaction_attachment_by_file_name_with_http_info(self, bank_transaction_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to createa an Attachment on BankTransaction by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transaction_attachment_by_file_name_with_http_info(bank_transaction_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str file_name: The name of the file being attached (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transaction_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `create_bank_transaction_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_bank_transaction_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_bank_transaction_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bank_transaction_history_record(self, bank_transaction_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create history record for a bank transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transaction_history_record(bank_transaction_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bank_transaction_history_record_with_http_info(bank_transaction_id, history_records, **kwargs)  # noqa: E501

    def create_bank_transaction_history_record_with_http_info(self, bank_transaction_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create history record for a bank transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transaction_history_record_with_http_info(bank_transaction_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transaction_history_record" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `create_bank_transaction_history_record`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_bank_transaction_history_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bank_transfer(self, bank_transfers, **kwargs):  # noqa: E501
        """Allows you to create a bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transfer(bank_transfers, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BankTransfers bank_transfers: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransfers
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bank_transfer_with_http_info(bank_transfers, **kwargs)  # noqa: E501

    def create_bank_transfer_with_http_info(self, bank_transfers, **kwargs):  # noqa: E501
        """Allows you to create a bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transfer_with_http_info(bank_transfers, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BankTransfers bank_transfers: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransfers, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transfer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfers' is set
        if ('bank_transfers' not in local_var_params or
                local_var_params['bank_transfers'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfers` when calling `create_bank_transfer`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bank_transfers' in local_var_params:
            body_params = local_var_params['bank_transfers']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransfers',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bank_transfer_attachment_by_file_name(self, bank_transfer_id, file_name, body, **kwargs):  # noqa: E501
        """create_bank_transfer_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transfer_attachment_by_file_name(bank_transfer_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str file_name: The name of the file being attached to a Bank Transfer (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bank_transfer_attachment_by_file_name_with_http_info(bank_transfer_id, file_name, body, **kwargs)  # noqa: E501

    def create_bank_transfer_attachment_by_file_name_with_http_info(self, bank_transfer_id, file_name, body, **kwargs):  # noqa: E501
        """create_bank_transfer_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transfer_attachment_by_file_name_with_http_info(bank_transfer_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str file_name: The name of the file being attached to a Bank Transfer (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transfer_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `create_bank_transfer_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_bank_transfer_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_bank_transfer_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bank_transfer_history_record(self, bank_transfer_id, history_records, **kwargs):  # noqa: E501
        """create_bank_transfer_history_record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transfer_history_record(bank_transfer_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bank_transfer_history_record_with_http_info(bank_transfer_id, history_records, **kwargs)  # noqa: E501

    def create_bank_transfer_history_record_with_http_info(self, bank_transfer_id, history_records, **kwargs):  # noqa: E501
        """create_bank_transfer_history_record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bank_transfer_history_record_with_http_info(bank_transfer_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bank_transfer_history_record" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `create_bank_transfer_history_record`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_bank_transfer_history_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_batch_payment(self, batch_payments, **kwargs):  # noqa: E501
        """Create one or many BatchPayments for invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_batch_payment(batch_payments, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BatchPayments batch_payments: Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BatchPayments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_batch_payment_with_http_info(batch_payments, **kwargs)  # noqa: E501

    def create_batch_payment_with_http_info(self, batch_payments, **kwargs):  # noqa: E501
        """Create one or many BatchPayments for invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_batch_payment_with_http_info(batch_payments, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BatchPayments batch_payments: Request of type BatchPayments containing a Payments array with one or more Payment objects (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['batch_payments']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_batch_payment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'batch_payments' is set
        if ('batch_payments' not in local_var_params or
                local_var_params['batch_payments'] is None):
            raise ApiValueError("Missing the required parameter `batch_payments` when calling `create_batch_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_payments' in local_var_params:
            body_params = local_var_params['batch_payments']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BatchPayments', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BatchPayments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_batch_payment_history_record(self, batch_payment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for a Batch Payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_batch_payment_history_record(batch_payment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str batch_payment_id: Unique identifier for BatchPayment (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_batch_payment_history_record_with_http_info(batch_payment_id, history_records, **kwargs)  # noqa: E501

    def create_batch_payment_history_record_with_http_info(self, batch_payment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for a Batch Payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_batch_payment_history_record_with_http_info(batch_payment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str batch_payment_id: Unique identifier for BatchPayment (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['batch_payment_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_batch_payment_history_record" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'batch_payment_id' is set
        if ('batch_payment_id' not in local_var_params or
                local_var_params['batch_payment_id'] is None):
            raise ApiValueError("Missing the required parameter `batch_payment_id` when calling `create_batch_payment_history_record`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_batch_payment_history_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'batch_payment_id' in local_var_params:
            path_params['BatchPaymentID'] = local_var_params['batch_payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BatchPayments/{BatchPaymentID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_branding_theme_payment_services(self, branding_theme_id, payment_service, **kwargs):  # noqa: E501
        """Allow for the creation of new custom payment service for specified Branding Theme  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_branding_theme_payment_services(branding_theme_id, payment_service, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str branding_theme_id: Unique identifier for a Branding Theme (required)
        :param PaymentService payment_service: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaymentServices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_branding_theme_payment_services_with_http_info(branding_theme_id, payment_service, **kwargs)  # noqa: E501

    def create_branding_theme_payment_services_with_http_info(self, branding_theme_id, payment_service, **kwargs):  # noqa: E501
        """Allow for the creation of new custom payment service for specified Branding Theme  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_branding_theme_payment_services_with_http_info(branding_theme_id, payment_service, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str branding_theme_id: Unique identifier for a Branding Theme (required)
        :param PaymentService payment_service: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['branding_theme_id', 'payment_service']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_branding_theme_payment_services" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'branding_theme_id' is set
        if ('branding_theme_id' not in local_var_params or
                local_var_params['branding_theme_id'] is None):
            raise ApiValueError("Missing the required parameter `branding_theme_id` when calling `create_branding_theme_payment_services`")  # noqa: E501
        # verify the required parameter 'payment_service' is set
        if ('payment_service' not in local_var_params or
                local_var_params['payment_service'] is None):
            raise ApiValueError("Missing the required parameter `payment_service` when calling `create_branding_theme_payment_services`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'branding_theme_id' in local_var_params:
            path_params['BrandingThemeID'] = local_var_params['branding_theme_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_service' in local_var_params:
            body_params = local_var_params['payment_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BrandingThemes/{BrandingThemeID}/PaymentServices', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaymentServices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact(self, contact, **kwargs):  # noqa: E501
        """create_contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact(contact, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Contact contact: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_contact_with_http_info(contact, **kwargs)  # noqa: E501

    def create_contact_with_http_info(self, contact, **kwargs):  # noqa: E501
        """create_contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_with_http_info(contact, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Contact contact: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact' is set
        if ('contact' not in local_var_params or
                local_var_params['contact'] is None):
            raise ApiValueError("Missing the required parameter `contact` when calling `create_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact' in local_var_params:
            body_params = local_var_params['contact']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact_attachment_by_file_name(self, contact_id, file_name, body, **kwargs):  # noqa: E501
        """create_contact_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_attachment_by_file_name(contact_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str file_name: Name for the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_contact_attachment_by_file_name_with_http_info(contact_id, file_name, body, **kwargs)  # noqa: E501

    def create_contact_attachment_by_file_name_with_http_info(self, contact_id, file_name, body, **kwargs):  # noqa: E501
        """create_contact_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_attachment_by_file_name_with_http_info(contact_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str file_name: Name for the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `create_contact_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_contact_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_contact_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact_group(self, **kwargs):  # noqa: E501
        """Allows you to create a contact group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_group(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ContactGroups contact_groups:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ContactGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_contact_group_with_http_info(**kwargs)  # noqa: E501

    def create_contact_group_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to create a contact group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_group_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ContactGroups contact_groups:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_groups']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact_groups' in local_var_params:
            body_params = local_var_params['contact_groups']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactGroups',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact_group_contacts(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to add Contacts to a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_group_contacts(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param Contacts contacts:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_contact_group_contacts_with_http_info(contact_group_id, **kwargs)  # noqa: E501

    def create_contact_group_contacts_with_http_info(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to add Contacts to a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_group_contacts_with_http_info(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param Contacts contacts:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_group_id', 'contacts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_group_contacts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_group_id' is set
        if ('contact_group_id' not in local_var_params or
                local_var_params['contact_group_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_group_id` when calling `create_contact_group_contacts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_group_id' in local_var_params:
            path_params['ContactGroupID'] = local_var_params['contact_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contacts' in local_var_params:
            body_params = local_var_params['contacts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups/{ContactGroupID}/Contacts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact_history(self, contact_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_history(contact_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_contact_history_with_http_info(contact_id, history_records, **kwargs)  # noqa: E501

    def create_contact_history_with_http_info(self, contact_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_history_with_http_info(contact_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `create_contact_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_contact_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_credit_note(self, **kwargs):  # noqa: E501
        """Allows you to create a credit note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param bool summarize_errors: shows validation errors for each credit note
        :param CreditNotes credit_notes:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreditNotes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_credit_note_with_http_info(**kwargs)  # noqa: E501

    def create_credit_note_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to create a credit note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param bool summarize_errors: shows validation errors for each credit note
        :param CreditNotes credit_notes:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['summarize_errors', 'credit_notes']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'summarize_errors' in local_var_params:
            query_params.append(('SummarizeErrors', local_var_params['summarize_errors']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'credit_notes' in local_var_params:
            body_params = local_var_params['credit_notes']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreditNotes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_credit_note_allocation(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to create Allocation on CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_allocation(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param Allocations allocations:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Allocations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_credit_note_allocation_with_http_info(credit_note_id, **kwargs)  # noqa: E501

    def create_credit_note_allocation_with_http_info(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to create Allocation on CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_allocation_with_http_info(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param Allocations allocations:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Allocations, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'allocations']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note_allocation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `create_credit_note_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'allocations' in local_var_params:
            body_params = local_var_params['allocations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/Allocations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Allocations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_credit_note_attachment_by_file_name(self, credit_note_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create Attachments on CreditNote by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_attachment_by_file_name(credit_note_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str file_name: Name of the file you are attaching to Credit Note (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_credit_note_attachment_by_file_name_with_http_info(credit_note_id, file_name, body, **kwargs)  # noqa: E501

    def create_credit_note_attachment_by_file_name_with_http_info(self, credit_note_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create Attachments on CreditNote by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_attachment_by_file_name_with_http_info(credit_note_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str file_name: Name of the file you are attaching to Credit Note (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `create_credit_note_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_credit_note_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_credit_note_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_credit_note_history(self, credit_note_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_history(credit_note_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_credit_note_history_with_http_info(credit_note_id, history_records, **kwargs)  # noqa: E501

    def create_credit_note_history_with_http_info(self, credit_note_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_credit_note_history_with_http_info(credit_note_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_credit_note_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `create_credit_note_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_credit_note_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_currency(self, currencies, **kwargs):  # noqa: E501
        """create_currency  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_currency(currencies, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Currencies currencies: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Currencies
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_currency_with_http_info(currencies, **kwargs)  # noqa: E501

    def create_currency_with_http_info(self, currencies, **kwargs):  # noqa: E501
        """create_currency  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_currency_with_http_info(currencies, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Currencies currencies: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Currencies, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['currencies']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_currency" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'currencies' is set
        if ('currencies' not in local_var_params or
                local_var_params['currencies'] is None):
            raise ApiValueError("Missing the required parameter `currencies` when calling `create_currency`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'currencies' in local_var_params:
            body_params = local_var_params['currencies']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Currencies', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Currencies',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_employee(self, employees, **kwargs):  # noqa: E501
        """Allows you to create new employees used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_employee(employees, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Employees employees: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Employees
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_employee_with_http_info(employees, **kwargs)  # noqa: E501

    def create_employee_with_http_info(self, employees, **kwargs):  # noqa: E501
        """Allows you to create new employees used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_employee_with_http_info(employees, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Employees employees: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['employees']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_employee" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'employees' is set
        if ('employees' not in local_var_params or
                local_var_params['employees'] is None):
            raise ApiValueError("Missing the required parameter `employees` when calling `create_employee`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'employees' in local_var_params:
            body_params = local_var_params['employees']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Employees', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Employees',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_expense_claim(self, expense_claims, **kwargs):  # noqa: E501
        """Allows you to retrieve expense claims  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_expense_claim(expense_claims, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ExpenseClaims expense_claims: (required)
        :param bool summarize_errors: shows validation errors for each expense claim
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExpenseClaims
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_expense_claim_with_http_info(expense_claims, **kwargs)  # noqa: E501

    def create_expense_claim_with_http_info(self, expense_claims, **kwargs):  # noqa: E501
        """Allows you to retrieve expense claims  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_expense_claim_with_http_info(expense_claims, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ExpenseClaims expense_claims: (required)
        :param bool summarize_errors: shows validation errors for each expense claim
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expense_claims', 'summarize_errors']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_expense_claim" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'expense_claims' is set
        if ('expense_claims' not in local_var_params or
                local_var_params['expense_claims'] is None):
            raise ApiValueError("Missing the required parameter `expense_claims` when calling `create_expense_claim`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'summarize_errors' in local_var_params:
            query_params.append(('SummarizeErrors', local_var_params['summarize_errors']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'expense_claims' in local_var_params:
            body_params = local_var_params['expense_claims']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ExpenseClaims', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExpenseClaims',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_expense_claim_history(self, expense_claim_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history records of an ExpenseClaim  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_expense_claim_history(expense_claim_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_expense_claim_history_with_http_info(expense_claim_id, history_records, **kwargs)  # noqa: E501

    def create_expense_claim_history_with_http_info(self, expense_claim_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history records of an ExpenseClaim  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_expense_claim_history_with_http_info(expense_claim_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expense_claim_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_expense_claim_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'expense_claim_id' is set
        if ('expense_claim_id' not in local_var_params or
                local_var_params['expense_claim_id'] is None):
            raise ApiValueError("Missing the required parameter `expense_claim_id` when calling `create_expense_claim_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_expense_claim_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'expense_claim_id' in local_var_params:
            path_params['ExpenseClaimID'] = local_var_params['expense_claim_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ExpenseClaims/{ExpenseClaimID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_invoice(self, invoices, **kwargs):  # noqa: E501
        """Allows you to create any sales invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invoice(invoices, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Invoices invoices: (required)
        :param bool summarize_errors: shows validation errors for each invoice
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Invoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_invoice_with_http_info(invoices, **kwargs)  # noqa: E501

    def create_invoice_with_http_info(self, invoices, **kwargs):  # noqa: E501
        """Allows you to create any sales invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invoice_with_http_info(invoices, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Invoices invoices: (required)
        :param bool summarize_errors: shows validation errors for each invoice
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoices', 'summarize_errors']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoices' is set
        if ('invoices' not in local_var_params or
                local_var_params['invoices'] is None):
            raise ApiValueError("Missing the required parameter `invoices` when calling `create_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'summarize_errors' in local_var_params:
            query_params.append(('SummarizeErrors', local_var_params['summarize_errors']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invoices' in local_var_params:
            body_params = local_var_params['invoices']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Invoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_invoice_attachment_by_file_name(self, invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create an Attachment on invoices or purchase bills by it's filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invoice_attachment_by_file_name(invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str file_name: Name of the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_invoice_attachment_by_file_name_with_http_info(invoice_id, file_name, body, **kwargs)  # noqa: E501

    def create_invoice_attachment_by_file_name_with_http_info(self, invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create an Attachment on invoices or purchase bills by it's filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invoice_attachment_by_file_name_with_http_info(invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str file_name: Name of the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoice_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `create_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_invoice_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_invoice_history(self, invoice_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invoice_history(invoice_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_invoice_history_with_http_info(invoice_id, history_records, **kwargs)  # noqa: E501

    def create_invoice_history_with_http_info(self, invoice_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invoice_history_with_http_info(invoice_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invoice_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `create_invoice_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_invoice_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_item(self, items, **kwargs):  # noqa: E501
        """Allows you to create an item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_item(items, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Items items: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Items
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_item_with_http_info(items, **kwargs)  # noqa: E501

    def create_item_with_http_info(self, items, **kwargs):  # noqa: E501
        """Allows you to create an item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_item_with_http_info(items, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Items items: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Items, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['items']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_item" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'items' is set
        if ('items' not in local_var_params or
                local_var_params['items'] is None):
            raise ApiValueError("Missing the required parameter `items` when calling `create_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'items' in local_var_params:
            body_params = local_var_params['items']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Items',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_item_history(self, item_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for items  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_item_history(item_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_item_history_with_http_info(item_id, history_records, **kwargs)  # noqa: E501

    def create_item_history_with_http_info(self, item_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for items  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_item_history_with_http_info(item_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['item_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_item_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in local_var_params or
                local_var_params['item_id'] is None):
            raise ApiValueError("Missing the required parameter `item_id` when calling `create_item_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_item_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'item_id' in local_var_params:
            path_params['ItemID'] = local_var_params['item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items/{ItemID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_linked_transaction(self, linked_transactions, **kwargs):  # noqa: E501
        """Allows you to create linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_linked_transaction(linked_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LinkedTransactions linked_transactions: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LinkedTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_linked_transaction_with_http_info(linked_transactions, **kwargs)  # noqa: E501

    def create_linked_transaction_with_http_info(self, linked_transactions, **kwargs):  # noqa: E501
        """Allows you to create linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_linked_transaction_with_http_info(linked_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LinkedTransactions linked_transactions: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['linked_transactions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_linked_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'linked_transactions' is set
        if ('linked_transactions' not in local_var_params or
                local_var_params['linked_transactions'] is None):
            raise ApiValueError("Missing the required parameter `linked_transactions` when calling `create_linked_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'linked_transactions' in local_var_params:
            body_params = local_var_params['linked_transactions']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LinkedTransactions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_manual_journal(self, manual_journals, **kwargs):  # noqa: E501
        """Allows you to create a manual journal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_manual_journal(manual_journals, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ManualJournals manual_journals: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ManualJournals
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_manual_journal_with_http_info(manual_journals, **kwargs)  # noqa: E501

    def create_manual_journal_with_http_info(self, manual_journals, **kwargs):  # noqa: E501
        """Allows you to create a manual journal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_manual_journal_with_http_info(manual_journals, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ManualJournals manual_journals: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journals']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_manual_journal" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journals' is set
        if ('manual_journals' not in local_var_params or
                local_var_params['manual_journals'] is None):
            raise ApiValueError("Missing the required parameter `manual_journals` when calling `create_manual_journal`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'manual_journals' in local_var_params:
            body_params = local_var_params['manual_journals']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManualJournals',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_manual_journal_attachment_by_file_name(self, manual_journal_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create a specified Attachment on ManualJournal by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_manual_journal_attachment_by_file_name(manual_journal_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str file_name: The name of the file being attached to a ManualJournal (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_manual_journal_attachment_by_file_name_with_http_info(manual_journal_id, file_name, body, **kwargs)  # noqa: E501

    def create_manual_journal_attachment_by_file_name_with_http_info(self, manual_journal_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create a specified Attachment on ManualJournal by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_manual_journal_attachment_by_file_name_with_http_info(manual_journal_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str file_name: The name of the file being attached to a ManualJournal (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_manual_journal_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `create_manual_journal_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_manual_journal_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_manual_journal_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_overpayment_allocation(self, overpayment_id, allocations, **kwargs):  # noqa: E501
        """Allows you to retrieve Allocations for overpayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_overpayment_allocation(overpayment_id, allocations, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param Allocations allocations: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Allocations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_overpayment_allocation_with_http_info(overpayment_id, allocations, **kwargs)  # noqa: E501

    def create_overpayment_allocation_with_http_info(self, overpayment_id, allocations, **kwargs):  # noqa: E501
        """Allows you to retrieve Allocations for overpayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_overpayment_allocation_with_http_info(overpayment_id, allocations, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param Allocations allocations: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Allocations, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['overpayment_id', 'allocations']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_overpayment_allocation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'overpayment_id' is set
        if ('overpayment_id' not in local_var_params or
                local_var_params['overpayment_id'] is None):
            raise ApiValueError("Missing the required parameter `overpayment_id` when calling `create_overpayment_allocation`")  # noqa: E501
        # verify the required parameter 'allocations' is set
        if ('allocations' not in local_var_params or
                local_var_params['allocations'] is None):
            raise ApiValueError("Missing the required parameter `allocations` when calling `create_overpayment_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'overpayment_id' in local_var_params:
            path_params['OverpaymentID'] = local_var_params['overpayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'allocations' in local_var_params:
            body_params = local_var_params['allocations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Overpayments/{OverpaymentID}/Allocations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Allocations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_overpayment_history(self, overpayment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create history records of an Overpayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_overpayment_history(overpayment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_overpayment_history_with_http_info(overpayment_id, history_records, **kwargs)  # noqa: E501

    def create_overpayment_history_with_http_info(self, overpayment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create history records of an Overpayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_overpayment_history_with_http_info(overpayment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['overpayment_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_overpayment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'overpayment_id' is set
        if ('overpayment_id' not in local_var_params or
                local_var_params['overpayment_id'] is None):
            raise ApiValueError("Missing the required parameter `overpayment_id` when calling `create_overpayment_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_overpayment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'overpayment_id' in local_var_params:
            path_params['OverpaymentID'] = local_var_params['overpayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Overpayments/{OverpaymentID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_payment(self, payments, **kwargs):  # noqa: E501
        """Allows you to create payments for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_payment(payments, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Payments payments: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Payments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_payment_with_http_info(payments, **kwargs)  # noqa: E501

    def create_payment_with_http_info(self, payments, **kwargs):  # noqa: E501
        """Allows you to create payments for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_payment_with_http_info(payments, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Payments payments: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['payments']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'payments' is set
        if ('payments' not in local_var_params or
                local_var_params['payments'] is None):
            raise ApiValueError("Missing the required parameter `payments` when calling `create_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payments' in local_var_params:
            body_params = local_var_params['payments']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Payments', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Payments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_payment_history(self, payment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for a payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_payment_history(payment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_payment_history_with_http_info(payment_id, history_records, **kwargs)  # noqa: E501

    def create_payment_history_with_http_info(self, payment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for a payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_payment_history_with_http_info(payment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['payment_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'payment_id' is set
        if ('payment_id' not in local_var_params or
                local_var_params['payment_id'] is None):
            raise ApiValueError("Missing the required parameter `payment_id` when calling `create_payment_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_payment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'payment_id' in local_var_params:
            path_params['PaymentID'] = local_var_params['payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Payments/{PaymentID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_payment_service(self, payment_services, **kwargs):  # noqa: E501
        """Allows you to create payment services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_payment_service(payment_services, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PaymentServices payment_services: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaymentServices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_payment_service_with_http_info(payment_services, **kwargs)  # noqa: E501

    def create_payment_service_with_http_info(self, payment_services, **kwargs):  # noqa: E501
        """Allows you to create payment services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_payment_service_with_http_info(payment_services, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PaymentServices payment_services: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['payment_services']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_payment_service" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'payment_services' is set
        if ('payment_services' not in local_var_params or
                local_var_params['payment_services'] is None):
            raise ApiValueError("Missing the required parameter `payment_services` when calling `create_payment_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_services' in local_var_params:
            body_params = local_var_params['payment_services']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PaymentServices', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaymentServices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_prepayment_allocation(self, prepayment_id, allocations, **kwargs):  # noqa: E501
        """Allows you to create an Allocation for prepayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prepayment_allocation(prepayment_id, allocations, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: (required)
        :param Allocations allocations: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Allocations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_prepayment_allocation_with_http_info(prepayment_id, allocations, **kwargs)  # noqa: E501

    def create_prepayment_allocation_with_http_info(self, prepayment_id, allocations, **kwargs):  # noqa: E501
        """Allows you to create an Allocation for prepayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prepayment_allocation_with_http_info(prepayment_id, allocations, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: (required)
        :param Allocations allocations: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Allocations, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['prepayment_id', 'allocations']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prepayment_allocation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'prepayment_id' is set
        if ('prepayment_id' not in local_var_params or
                local_var_params['prepayment_id'] is None):
            raise ApiValueError("Missing the required parameter `prepayment_id` when calling `create_prepayment_allocation`")  # noqa: E501
        # verify the required parameter 'allocations' is set
        if ('allocations' not in local_var_params or
                local_var_params['allocations'] is None):
            raise ApiValueError("Missing the required parameter `allocations` when calling `create_prepayment_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'prepayment_id' in local_var_params:
            path_params['PrepaymentID'] = local_var_params['prepayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'allocations' in local_var_params:
            body_params = local_var_params['allocations']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Prepayments/{PrepaymentID}/Allocations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Allocations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_prepayment_history(self, prepayment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for an Prepayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prepayment_history(prepayment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: Unique identifier for a PrePayment (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_prepayment_history_with_http_info(prepayment_id, history_records, **kwargs)  # noqa: E501

    def create_prepayment_history_with_http_info(self, prepayment_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create a history record for an Prepayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prepayment_history_with_http_info(prepayment_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: Unique identifier for a PrePayment (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['prepayment_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prepayment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'prepayment_id' is set
        if ('prepayment_id' not in local_var_params or
                local_var_params['prepayment_id'] is None):
            raise ApiValueError("Missing the required parameter `prepayment_id` when calling `create_prepayment_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_prepayment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'prepayment_id' in local_var_params:
            path_params['PrepaymentID'] = local_var_params['prepayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Prepayments/{PrepaymentID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_purchase_order(self, purchase_orders, **kwargs):  # noqa: E501
        """Allows you to create purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_purchase_order(purchase_orders, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PurchaseOrders purchase_orders: (required)
        :param bool summarize_errors: shows validation errors for each purchase order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PurchaseOrders
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_purchase_order_with_http_info(purchase_orders, **kwargs)  # noqa: E501

    def create_purchase_order_with_http_info(self, purchase_orders, **kwargs):  # noqa: E501
        """Allows you to create purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_purchase_order_with_http_info(purchase_orders, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PurchaseOrders purchase_orders: (required)
        :param bool summarize_errors: shows validation errors for each purchase order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['purchase_orders', 'summarize_errors']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_purchase_order" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'purchase_orders' is set
        if ('purchase_orders' not in local_var_params or
                local_var_params['purchase_orders'] is None):
            raise ApiValueError("Missing the required parameter `purchase_orders` when calling `create_purchase_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'summarize_errors' in local_var_params:
            query_params.append(('SummarizeErrors', local_var_params['summarize_errors']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'purchase_orders' in local_var_params:
            body_params = local_var_params['purchase_orders']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PurchaseOrders', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PurchaseOrders',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_purchase_order_history(self, purchase_order_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create HistoryRecord for purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_purchase_order_history(purchase_order_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_purchase_order_history_with_http_info(purchase_order_id, history_records, **kwargs)  # noqa: E501

    def create_purchase_order_history_with_http_info(self, purchase_order_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create HistoryRecord for purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_purchase_order_history_with_http_info(purchase_order_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['purchase_order_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_purchase_order_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'purchase_order_id' is set
        if ('purchase_order_id' not in local_var_params or
                local_var_params['purchase_order_id'] is None):
            raise ApiValueError("Missing the required parameter `purchase_order_id` when calling `create_purchase_order_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_purchase_order_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'purchase_order_id' in local_var_params:
            path_params['PurchaseOrderID'] = local_var_params['purchase_order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PurchaseOrders/{PurchaseOrderID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_receipt(self, receipts, **kwargs):  # noqa: E501
        """Allows you to create draft expense claim receipts for any user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_receipt(receipts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Receipts receipts: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Receipts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_receipt_with_http_info(receipts, **kwargs)  # noqa: E501

    def create_receipt_with_http_info(self, receipts, **kwargs):  # noqa: E501
        """Allows you to create draft expense claim receipts for any user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_receipt_with_http_info(receipts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Receipts receipts: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_receipt" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipts' is set
        if ('receipts' not in local_var_params or
                local_var_params['receipts'] is None):
            raise ApiValueError("Missing the required parameter `receipts` when calling `create_receipt`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'receipts' in local_var_params:
            body_params = local_var_params['receipts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Receipts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_receipt_attachment_by_file_name(self, receipt_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create Attachment on expense claim receipts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_receipt_attachment_by_file_name(receipt_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str file_name: The name of the file being attached to the Receipt (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_receipt_attachment_by_file_name_with_http_info(receipt_id, file_name, body, **kwargs)  # noqa: E501

    def create_receipt_attachment_by_file_name_with_http_info(self, receipt_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create Attachment on expense claim receipts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_receipt_attachment_by_file_name_with_http_info(receipt_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str file_name: The name of the file being attached to the Receipt (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_receipt_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `create_receipt_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_receipt_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_receipt_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_receipt_history(self, receipt_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Receipt  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_receipt_history(receipt_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_receipt_history_with_http_info(receipt_id, history_records, **kwargs)  # noqa: E501

    def create_receipt_history_with_http_info(self, receipt_id, history_records, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Receipt  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_receipt_history_with_http_info(receipt_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_receipt_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `create_receipt_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_receipt_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repeating_invoice_attachment_by_file_name(self, repeating_invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create attachment on repeating invoices by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repeating_invoice_attachment_by_file_name(repeating_invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str file_name: The name of the file being attached to a Repeating Invoice (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repeating_invoice_attachment_by_file_name_with_http_info(repeating_invoice_id, file_name, body, **kwargs)  # noqa: E501

    def create_repeating_invoice_attachment_by_file_name_with_http_info(self, repeating_invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to create attachment on repeating invoices by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repeating_invoice_attachment_by_file_name_with_http_info(repeating_invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str file_name: The name of the file being attached to a Repeating Invoice (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repeating_invoice_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `create_repeating_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `create_repeating_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_repeating_invoice_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repeating_invoice_history(self, repeating_invoice_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create history for a repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repeating_invoice_history(repeating_invoice_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param HistoryRecords history_records: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repeating_invoice_history_with_http_info(repeating_invoice_id, history_records, **kwargs)  # noqa: E501

    def create_repeating_invoice_history_with_http_info(self, repeating_invoice_id, history_records, **kwargs):  # noqa: E501
        """Allows you to create history for a repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repeating_invoice_history_with_http_info(repeating_invoice_id, history_records, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param HistoryRecords history_records: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id', 'history_records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repeating_invoice_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `create_repeating_invoice_history`")  # noqa: E501
        # verify the required parameter 'history_records' is set
        if ('history_records' not in local_var_params or
                local_var_params['history_records'] is None):
            raise ApiValueError("Missing the required parameter `history_records` when calling `create_repeating_invoice_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'history_records' in local_var_params:
            body_params = local_var_params['history_records']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/History', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tax_rate(self, tax_rates, **kwargs):  # noqa: E501
        """Allows you to create Tax Rates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tax_rate(tax_rates, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TaxRates tax_rates: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaxRates
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_tax_rate_with_http_info(tax_rates, **kwargs)  # noqa: E501

    def create_tax_rate_with_http_info(self, tax_rates, **kwargs):  # noqa: E501
        """Allows you to create Tax Rates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tax_rate_with_http_info(tax_rates, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TaxRates tax_rates: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tax_rates']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tax_rate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tax_rates' is set
        if ('tax_rates' not in local_var_params or
                local_var_params['tax_rates'] is None):
            raise ApiValueError("Missing the required parameter `tax_rates` when calling `create_tax_rate`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tax_rates' in local_var_params:
            body_params = local_var_params['tax_rates']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TaxRates', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaxRates',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tracking_category(self, tracking_category, **kwargs):  # noqa: E501
        """Allows you to create tracking categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tracking_category(tracking_category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TrackingCategory tracking_category: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingCategories
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_tracking_category_with_http_info(tracking_category, **kwargs)  # noqa: E501

    def create_tracking_category_with_http_info(self, tracking_category, **kwargs):  # noqa: E501
        """Allows you to create tracking categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tracking_category_with_http_info(tracking_category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TrackingCategory tracking_category: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tracking_category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tracking_category" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tracking_category' is set
        if ('tracking_category' not in local_var_params or
                local_var_params['tracking_category'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category` when calling `create_tracking_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tracking_category' in local_var_params:
            body_params = local_var_params['tracking_category']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingCategories',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tracking_options(self, tracking_category_id, tracking_option, **kwargs):  # noqa: E501
        """Allows you to create options for a specified tracking category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tracking_options(tracking_category_id, tracking_option, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param TrackingOption tracking_option: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingOptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_tracking_options_with_http_info(tracking_category_id, tracking_option, **kwargs)  # noqa: E501

    def create_tracking_options_with_http_info(self, tracking_category_id, tracking_option, **kwargs):  # noqa: E501
        """Allows you to create options for a specified tracking category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tracking_options_with_http_info(tracking_category_id, tracking_option, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param TrackingOption tracking_option: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingOptions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tracking_category_id', 'tracking_option']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tracking_options" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tracking_category_id' is set
        if ('tracking_category_id' not in local_var_params or
                local_var_params['tracking_category_id'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category_id` when calling `create_tracking_options`")  # noqa: E501
        # verify the required parameter 'tracking_option' is set
        if ('tracking_option' not in local_var_params or
                local_var_params['tracking_option'] is None):
            raise ApiValueError("Missing the required parameter `tracking_option` when calling `create_tracking_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tracking_category_id' in local_var_params:
            path_params['TrackingCategoryID'] = local_var_params['tracking_category_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tracking_option' in local_var_params:
            body_params = local_var_params['tracking_option']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories/{TrackingCategoryID}/Options', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingOptions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account(self, account_id, **kwargs):  # noqa: E501
        """Allows you to delete a chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for retrieving single object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Accounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_account_with_http_info(account_id, **kwargs)  # noqa: E501

    def delete_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Allows you to delete a chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for retrieving single object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `delete_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Accounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact_group_contact(self, contact_group_id, contact_id, **kwargs):  # noqa: E501
        """Allows you to delete a specific Contact from a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_group_contact(contact_group_id, contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param str contact_id: Unique identifier for a Contact (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_contact_group_contact_with_http_info(contact_group_id, contact_id, **kwargs)  # noqa: E501

    def delete_contact_group_contact_with_http_info(self, contact_group_id, contact_id, **kwargs):  # noqa: E501
        """Allows you to delete a specific Contact from a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_group_contact_with_http_info(contact_group_id, contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param str contact_id: Unique identifier for a Contact (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_group_id', 'contact_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_group_contact" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_group_id' is set
        if ('contact_group_id' not in local_var_params or
                local_var_params['contact_group_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_group_id` when calling `delete_contact_group_contact`")  # noqa: E501
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `delete_contact_group_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_group_id' in local_var_params:
            path_params['ContactGroupID'] = local_var_params['contact_group_id']  # noqa: E501
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups/{ContactGroupID}/Contacts/{ContactID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact_group_contacts(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to delete  all Contacts from a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_group_contacts(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_contact_group_contacts_with_http_info(contact_group_id, **kwargs)  # noqa: E501

    def delete_contact_group_contacts_with_http_info(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to delete  all Contacts from a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_group_contacts_with_http_info(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_group_contacts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_group_id' is set
        if ('contact_group_id' not in local_var_params or
                local_var_params['contact_group_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_group_id` when calling `delete_contact_group_contacts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_group_id' in local_var_params:
            path_params['ContactGroupID'] = local_var_params['contact_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups/{ContactGroupID}/Contacts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_item(self, item_id, **kwargs):  # noqa: E501
        """Allows you to delete a specified item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_item(item_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_item_with_http_info(item_id, **kwargs)  # noqa: E501

    def delete_item_with_http_info(self, item_id, **kwargs):  # noqa: E501
        """Allows you to delete a specified item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_item_with_http_info(item_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['item_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_item" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in local_var_params or
                local_var_params['item_id'] is None):
            raise ApiValueError("Missing the required parameter `item_id` when calling `delete_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'item_id' in local_var_params:
            path_params['ItemID'] = local_var_params['item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items/{ItemID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_linked_transaction(self, linked_transaction_id, **kwargs):  # noqa: E501
        """Allows you to delete a specified linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_linked_transaction(linked_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_linked_transaction_with_http_info(linked_transaction_id, **kwargs)  # noqa: E501

    def delete_linked_transaction_with_http_info(self, linked_transaction_id, **kwargs):  # noqa: E501
        """Allows you to delete a specified linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_linked_transaction_with_http_info(linked_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['linked_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_linked_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'linked_transaction_id' is set
        if ('linked_transaction_id' not in local_var_params or
                local_var_params['linked_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `linked_transaction_id` when calling `delete_linked_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'linked_transaction_id' in local_var_params:
            path_params['LinkedTransactionID'] = local_var_params['linked_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LinkedTransactions/{LinkedTransactionID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_payment(self, payment_id, payments, **kwargs):  # noqa: E501
        """Allows you to update a specified payment for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_payment(payment_id, payments, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param Payments payments: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Payments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_payment_with_http_info(payment_id, payments, **kwargs)  # noqa: E501

    def delete_payment_with_http_info(self, payment_id, payments, **kwargs):  # noqa: E501
        """Allows you to update a specified payment for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_payment_with_http_info(payment_id, payments, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param Payments payments: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['payment_id', 'payments']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_payment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'payment_id' is set
        if ('payment_id' not in local_var_params or
                local_var_params['payment_id'] is None):
            raise ApiValueError("Missing the required parameter `payment_id` when calling `delete_payment`")  # noqa: E501
        # verify the required parameter 'payments' is set
        if ('payments' not in local_var_params or
                local_var_params['payments'] is None):
            raise ApiValueError("Missing the required parameter `payments` when calling `delete_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'payment_id' in local_var_params:
            path_params['PaymentID'] = local_var_params['payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payments' in local_var_params:
            body_params = local_var_params['payments']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Payments/{PaymentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Payments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tracking_category(self, tracking_category_id, **kwargs):  # noqa: E501
        """Allows you to delete tracking categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tracking_category(tracking_category_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingCategories
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_tracking_category_with_http_info(tracking_category_id, **kwargs)  # noqa: E501

    def delete_tracking_category_with_http_info(self, tracking_category_id, **kwargs):  # noqa: E501
        """Allows you to delete tracking categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tracking_category_with_http_info(tracking_category_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tracking_category_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tracking_category" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tracking_category_id' is set
        if ('tracking_category_id' not in local_var_params or
                local_var_params['tracking_category_id'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category_id` when calling `delete_tracking_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tracking_category_id' in local_var_params:
            path_params['TrackingCategoryID'] = local_var_params['tracking_category_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories/{TrackingCategoryID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingCategories',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tracking_options(self, tracking_category_id, tracking_option_id, **kwargs):  # noqa: E501
        """Allows you to delete a specified option for a specified tracking category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tracking_options(tracking_category_id, tracking_option_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param str tracking_option_id: Unique identifier for a Tracking Option (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingOptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_tracking_options_with_http_info(tracking_category_id, tracking_option_id, **kwargs)  # noqa: E501

    def delete_tracking_options_with_http_info(self, tracking_category_id, tracking_option_id, **kwargs):  # noqa: E501
        """Allows you to delete a specified option for a specified tracking category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tracking_options_with_http_info(tracking_category_id, tracking_option_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param str tracking_option_id: Unique identifier for a Tracking Option (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingOptions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tracking_category_id', 'tracking_option_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tracking_options" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tracking_category_id' is set
        if ('tracking_category_id' not in local_var_params or
                local_var_params['tracking_category_id'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category_id` when calling `delete_tracking_options`")  # noqa: E501
        # verify the required parameter 'tracking_option_id' is set
        if ('tracking_option_id' not in local_var_params or
                local_var_params['tracking_option_id'] is None):
            raise ApiValueError("Missing the required parameter `tracking_option_id` when calling `delete_tracking_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tracking_category_id' in local_var_params:
            path_params['TrackingCategoryID'] = local_var_params['tracking_category_id']  # noqa: E501
        if 'tracking_option_id' in local_var_params:
            path_params['TrackingOptionID'] = local_var_params['tracking_option_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingOptions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def email_invoice(self, invoice_id, request_empty, **kwargs):  # noqa: E501
        """Allows you to email a copy of invoice to related Contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_invoice(invoice_id, request_empty, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param RequestEmpty request_empty: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.email_invoice_with_http_info(invoice_id, request_empty, **kwargs)  # noqa: E501

    def email_invoice_with_http_info(self, invoice_id, request_empty, **kwargs):  # noqa: E501
        """Allows you to email a copy of invoice to related Contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_invoice_with_http_info(invoice_id, request_empty, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param RequestEmpty request_empty: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'request_empty']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_invoice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `email_invoice`")  # noqa: E501
        # verify the required parameter 'request_empty' is set
        if ('request_empty' not in local_var_params or
                local_var_params['request_empty'] is None):
            raise ApiValueError("Missing the required parameter `request_empty` when calling `email_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_empty' in local_var_params:
            body_params = local_var_params['request_empty']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/Email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account(self, account_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a single chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for retrieving single object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Accounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501

    def get_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a single chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for retrieving single object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `get_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Accounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_attachment_by_file_name(self, account_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachment on Account by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_attachment_by_file_name(account_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str file_name: Name of the attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_account_attachment_by_file_name_with_http_info(account_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_account_attachment_by_file_name_with_http_info(self, account_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachment on Account by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_attachment_by_file_name_with_http_info(account_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str file_name: Name of the attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `get_account_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_account_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_account_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_attachment_by_id(self, account_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specific Attachment on Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_attachment_by_id(account_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str attachment_id: Unique identifier for Attachment object (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_account_attachment_by_id_with_http_info(account_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_account_attachment_by_id_with_http_info(self, account_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specific Attachment on Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_attachment_by_id_with_http_info(account_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str attachment_id: Unique identifier for Attachment object (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `get_account_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_account_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_account_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_attachments(self, account_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments for accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_attachments(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_account_attachments_with_http_info(account_id, **kwargs)  # noqa: E501

    def get_account_attachments_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments for accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_attachments_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `get_account_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_accounts(self, **kwargs):  # noqa: E501
        """Allows you to retrieve the full chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Accounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_accounts_with_http_info(**kwargs)  # noqa: E501

    def get_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve the full chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Accounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transaction(self, bank_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a single spend or receive money transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction(bank_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transaction_with_http_info(bank_transaction_id, **kwargs)  # noqa: E501

    def get_bank_transaction_with_http_info(self, bank_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a single spend or receive money transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_with_http_info(bank_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `get_bank_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transaction_attachment_by_file_name(self, bank_transaction_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on BankTransaction by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_attachment_by_file_name(bank_transaction_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str file_name: The name of the file being attached (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transaction_attachment_by_file_name_with_http_info(bank_transaction_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_bank_transaction_attachment_by_file_name_with_http_info(self, bank_transaction_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on BankTransaction by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_attachment_by_file_name_with_http_info(bank_transaction_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str file_name: The name of the file being attached (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `get_bank_transaction_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_bank_transaction_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_bank_transaction_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transaction_attachment_by_id(self, bank_transaction_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on a specific BankTransaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_attachment_by_id(bank_transaction_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str attachment_id: Xero generated unique identifier for an attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transaction_attachment_by_id_with_http_info(bank_transaction_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_bank_transaction_attachment_by_id_with_http_info(self, bank_transaction_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on a specific BankTransaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_attachment_by_id_with_http_info(bank_transaction_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str attachment_id: Xero generated unique identifier for an attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `get_bank_transaction_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_bank_transaction_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_bank_transaction_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transaction_attachments(self, bank_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve any attachments to bank transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_attachments(bank_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transaction_attachments_with_http_info(bank_transaction_id, **kwargs)  # noqa: E501

    def get_bank_transaction_attachments_with_http_info(self, bank_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve any attachments to bank transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transaction_attachments_with_http_info(bank_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transaction_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `get_bank_transaction_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transactions(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any spend or receive money transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transactions(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transactions_with_http_info(**kwargs)  # noqa: E501

    def get_bank_transactions_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any spend or receive money transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transactions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 bank transactions will be returned in a single API call with line items shown for each bank transaction
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'page', 'unitdp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transactions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'unitdp' in local_var_params:
            query_params.append(('unitdp', local_var_params['unitdp']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transactions_history(self, bank_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history from a bank transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transactions_history(bank_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transactions_history_with_http_info(bank_transaction_id, **kwargs)  # noqa: E501

    def get_bank_transactions_history_with_http_info(self, bank_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history from a bank transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transactions_history_with_http_info(bank_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transactions_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `get_bank_transactions_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transfer(self, bank_transfer_id, **kwargs):  # noqa: E501
        """Allows you to retrieve any bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer(bank_transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransfers
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transfer_with_http_info(bank_transfer_id, **kwargs)  # noqa: E501

    def get_bank_transfer_with_http_info(self, bank_transfer_id, **kwargs):  # noqa: E501
        """Allows you to retrieve any bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_with_http_info(bank_transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransfers, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `get_bank_transfer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransfers',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transfer_attachment_by_file_name(self, bank_transfer_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on BankTransfer by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_attachment_by_file_name(bank_transfer_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str file_name: The name of the file being attached to a Bank Transfer (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transfer_attachment_by_file_name_with_http_info(bank_transfer_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_bank_transfer_attachment_by_file_name_with_http_info(self, bank_transfer_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on BankTransfer by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_attachment_by_file_name_with_http_info(bank_transfer_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str file_name: The name of the file being attached to a Bank Transfer (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `get_bank_transfer_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_bank_transfer_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_bank_transfer_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transfer_attachment_by_id(self, bank_transfer_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on BankTransfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_attachment_by_id(bank_transfer_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str attachment_id: Xero generated unique identifier for an Attachment to a bank transfer (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transfer_attachment_by_id_with_http_info(bank_transfer_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_bank_transfer_attachment_by_id_with_http_info(self, bank_transfer_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on BankTransfer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_attachment_by_id_with_http_info(bank_transfer_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str attachment_id: Xero generated unique identifier for an Attachment to a bank transfer (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `get_bank_transfer_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_bank_transfer_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_bank_transfer_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transfer_attachments(self, bank_transfer_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments from  bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_attachments(bank_transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transfer_attachments_with_http_info(bank_transfer_id, **kwargs)  # noqa: E501

    def get_bank_transfer_attachments_with_http_info(self, bank_transfer_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments from  bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_attachments_with_http_info(bank_transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `get_bank_transfer_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transfer_history(self, bank_transfer_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history from a bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_history(bank_transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transfer_history_with_http_info(bank_transfer_id, **kwargs)  # noqa: E501

    def get_bank_transfer_history_with_http_info(self, bank_transfer_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history from a bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfer_history_with_http_info(bank_transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfer_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `get_bank_transfer_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_transfers(self, **kwargs):  # noqa: E501
        """Allows you to retrieve all bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfers(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransfers
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bank_transfers_with_http_info(**kwargs)  # noqa: E501

    def get_bank_transfers_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve all bank transfers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_transfers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransfers, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_transfers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransfers',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_batch_payment_history(self, batch_payment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history from a Batch Payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_batch_payment_history(batch_payment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str batch_payment_id: Unique identifier for BatchPayment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_batch_payment_history_with_http_info(batch_payment_id, **kwargs)  # noqa: E501

    def get_batch_payment_history_with_http_info(self, batch_payment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history from a Batch Payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_batch_payment_history_with_http_info(batch_payment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str batch_payment_id: Unique identifier for BatchPayment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['batch_payment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_payment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'batch_payment_id' is set
        if ('batch_payment_id' not in local_var_params or
                local_var_params['batch_payment_id'] is None):
            raise ApiValueError("Missing the required parameter `batch_payment_id` when calling `get_batch_payment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'batch_payment_id' in local_var_params:
            path_params['BatchPaymentID'] = local_var_params['batch_payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BatchPayments/{BatchPaymentID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_batch_payments(self, **kwargs):  # noqa: E501
        """Retrieve either one or many BatchPayments for invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_batch_payments(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BatchPayments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_batch_payments_with_http_info(**kwargs)  # noqa: E501

    def get_batch_payments_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve either one or many BatchPayments for invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_batch_payments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BatchPayments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_payments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BatchPayments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BatchPayments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_branding_theme(self, branding_theme_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specific BrandingThemes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branding_theme(branding_theme_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str branding_theme_id: Unique identifier for a Branding Theme (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BrandingThemes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_branding_theme_with_http_info(branding_theme_id, **kwargs)  # noqa: E501

    def get_branding_theme_with_http_info(self, branding_theme_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specific BrandingThemes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branding_theme_with_http_info(branding_theme_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str branding_theme_id: Unique identifier for a Branding Theme (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BrandingThemes, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['branding_theme_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branding_theme" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'branding_theme_id' is set
        if ('branding_theme_id' not in local_var_params or
                local_var_params['branding_theme_id'] is None):
            raise ApiValueError("Missing the required parameter `branding_theme_id` when calling `get_branding_theme`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'branding_theme_id' in local_var_params:
            path_params['BrandingThemeID'] = local_var_params['branding_theme_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BrandingThemes/{BrandingThemeID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BrandingThemes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_branding_theme_payment_services(self, branding_theme_id, **kwargs):  # noqa: E501
        """Allows you to retrieve the Payment services for a Branding Theme  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branding_theme_payment_services(branding_theme_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str branding_theme_id: Unique identifier for a Branding Theme (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaymentServices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_branding_theme_payment_services_with_http_info(branding_theme_id, **kwargs)  # noqa: E501

    def get_branding_theme_payment_services_with_http_info(self, branding_theme_id, **kwargs):  # noqa: E501
        """Allows you to retrieve the Payment services for a Branding Theme  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branding_theme_payment_services_with_http_info(branding_theme_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str branding_theme_id: Unique identifier for a Branding Theme (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['branding_theme_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branding_theme_payment_services" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'branding_theme_id' is set
        if ('branding_theme_id' not in local_var_params or
                local_var_params['branding_theme_id'] is None):
            raise ApiValueError("Missing the required parameter `branding_theme_id` when calling `get_branding_theme_payment_services`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'branding_theme_id' in local_var_params:
            path_params['BrandingThemeID'] = local_var_params['branding_theme_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BrandingThemes/{BrandingThemeID}/PaymentServices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaymentServices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_branding_themes(self, **kwargs):  # noqa: E501
        """Allows you to retrieve all the BrandingThemes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branding_themes(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BrandingThemes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_branding_themes_with_http_info(**kwargs)  # noqa: E501

    def get_branding_themes_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve all the BrandingThemes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_branding_themes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BrandingThemes, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branding_themes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BrandingThemes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BrandingThemes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve, add and update contacts in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_with_http_info(contact_id, **kwargs)  # noqa: E501

    def get_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve, add and update contacts in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_attachment_by_file_name(self, contact_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on Contacts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_attachment_by_file_name(contact_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str file_name: Name for the file you are attaching (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_attachment_by_file_name_with_http_info(contact_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_contact_attachment_by_file_name_with_http_info(self, contact_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on Contacts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_attachment_by_file_name_with_http_info(contact_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str file_name: Name for the file you are attaching (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_contact_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_contact_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_contact_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_attachment_by_id(self, contact_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on Contacts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_attachment_by_id(contact_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_attachment_by_id_with_http_info(contact_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_contact_attachment_by_id_with_http_info(self, contact_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on Contacts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_attachment_by_id_with_http_info(contact_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_contact_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_contact_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_contact_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_attachments(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve, add and update contacts in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_attachments(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_attachments_with_http_info(contact_id, **kwargs)  # noqa: E501

    def get_contact_attachments_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve, add and update contacts in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_attachments_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_contact_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_cis_settings(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve CISSettings for a contact in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_cis_settings(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CISSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_cis_settings_with_http_info(contact_id, **kwargs)  # noqa: E501

    def get_contact_cis_settings_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve CISSettings for a contact in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_cis_settings_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CISSettings, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_cis_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_contact_cis_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/CISSettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CISSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_group(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a unique Contract Group by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_group(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ContactGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_group_with_http_info(contact_group_id, **kwargs)  # noqa: E501

    def get_contact_group_with_http_info(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a unique Contract Group by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_group_with_http_info(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_group_id' is set
        if ('contact_group_id' not in local_var_params or
                local_var_params['contact_group_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_group_id` when calling `get_contact_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_group_id' in local_var_params:
            path_params['ContactGroupID'] = local_var_params['contact_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups/{ContactGroupID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactGroups',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_groups(self, **kwargs):  # noqa: E501
        """Allows you to retrieve the ContactID and Name of all the contacts in a contact group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ContactGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_groups_with_http_info(**kwargs)  # noqa: E501

    def get_contact_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve the ContactID and Name of all the contacts in a contact group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_groups" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactGroups',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_history(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_history(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contact_history_with_http_info(contact_id, **kwargs)  # noqa: E501

    def get_contact_history_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_history_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_contact_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contacts(self, **kwargs):  # noqa: E501
        """Allows you to retrieve, add and update contacts in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param str i_ds: Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call.
        :param int page: e.g. page=1 - Up to 100 contacts will be returned in a single API call.
        :param bool include_archived: e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contacts_with_http_info(**kwargs)  # noqa: E501

    def get_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve, add and update contacts in a Xero organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param str i_ds: Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call.
        :param int page: e.g. page=1 - Up to 100 contacts will be returned in a single API call.
        :param bool include_archived: e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'i_ds', 'page', 'include_archived']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contacts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'i_ds' in local_var_params:
            query_params.append(('IDs', local_var_params['i_ds']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'include_archived' in local_var_params:
            query_params.append(('includeArchived', local_var_params['include_archived']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_note(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specific credit note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreditNotes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_note_with_http_info(credit_note_id, **kwargs)  # noqa: E501

    def get_credit_note_with_http_info(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specific credit note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_with_http_info(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `get_credit_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreditNotes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_note_as_pdf(self, credit_note_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Credit Note as PDF files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_as_pdf(credit_note_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_note_as_pdf_with_http_info(credit_note_id, content_type, **kwargs)  # noqa: E501

    def get_credit_note_as_pdf_with_http_info(self, credit_note_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Credit Note as PDF files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_as_pdf_with_http_info(credit_note_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_as_pdf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `get_credit_note_as_pdf`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_credit_note_as_pdf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/pdf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_note_attachment_by_file_name(self, credit_note_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on CreditNote by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_attachment_by_file_name(credit_note_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str file_name: Name of the file you are attaching to Credit Note (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_note_attachment_by_file_name_with_http_info(credit_note_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_credit_note_attachment_by_file_name_with_http_info(self, credit_note_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on CreditNote by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_attachment_by_file_name_with_http_info(credit_note_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str file_name: Name of the file you are attaching to Credit Note (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `get_credit_note_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_credit_note_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_credit_note_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_note_attachment_by_id(self, credit_note_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_attachment_by_id(credit_note_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_note_attachment_by_id_with_http_info(credit_note_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_credit_note_attachment_by_id_with_http_info(self, credit_note_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_attachment_by_id_with_http_info(credit_note_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `get_credit_note_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_credit_note_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_credit_note_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_note_attachments(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments for credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_attachments(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_note_attachments_with_http_info(credit_note_id, **kwargs)  # noqa: E501

    def get_credit_note_attachments_with_http_info(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments for credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_attachments_with_http_info(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `get_credit_note_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_note_history(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_history(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_note_history_with_http_info(credit_note_id, **kwargs)  # noqa: E501

    def get_credit_note_history_with_http_info(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an CreditNote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_note_history_with_http_info(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_note_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `get_credit_note_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credit_notes(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_notes(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreditNotes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credit_notes_with_http_info(**kwargs)  # noqa: E501

    def get_credit_notes_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credit_notes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 credit notes will be returned in a single API call with line items shown for each credit note
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credit_notes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreditNotes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_currencies(self, **kwargs):  # noqa: E501
        """Allows you to retrieve currencies for your organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_currencies(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Currencies
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_currencies_with_http_info(**kwargs)  # noqa: E501

    def get_currencies_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve currencies for your organisation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_currencies_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Currencies, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_currencies" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Currencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Currencies',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_employee(self, employee_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specific employee used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_employee(employee_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str employee_id: Unique identifier for a Employee (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Employees
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_employee_with_http_info(employee_id, **kwargs)  # noqa: E501

    def get_employee_with_http_info(self, employee_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specific employee used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_employee_with_http_info(employee_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str employee_id: Unique identifier for a Employee (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['employee_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employee" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'employee_id' is set
        if ('employee_id' not in local_var_params or
                local_var_params['employee_id'] is None):
            raise ApiValueError("Missing the required parameter `employee_id` when calling `get_employee`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'employee_id' in local_var_params:
            path_params['EmployeeID'] = local_var_params['employee_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Employees/{EmployeeID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Employees',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_employees(self, **kwargs):  # noqa: E501
        """Allows you to retrieve employees used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_employees(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Employees
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_employees_with_http_info(**kwargs)  # noqa: E501

    def get_employees_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve employees used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_employees_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_employees" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Employees', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Employees',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_expense_claim(self, expense_claim_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified expense claim  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_expense_claim(expense_claim_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExpenseClaims
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_expense_claim_with_http_info(expense_claim_id, **kwargs)  # noqa: E501

    def get_expense_claim_with_http_info(self, expense_claim_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified expense claim  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_expense_claim_with_http_info(expense_claim_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expense_claim_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expense_claim" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'expense_claim_id' is set
        if ('expense_claim_id' not in local_var_params or
                local_var_params['expense_claim_id'] is None):
            raise ApiValueError("Missing the required parameter `expense_claim_id` when calling `get_expense_claim`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'expense_claim_id' in local_var_params:
            path_params['ExpenseClaimID'] = local_var_params['expense_claim_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ExpenseClaims/{ExpenseClaimID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExpenseClaims',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_expense_claim_history(self, expense_claim_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an ExpenseClaim  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_expense_claim_history(expense_claim_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_expense_claim_history_with_http_info(expense_claim_id, **kwargs)  # noqa: E501

    def get_expense_claim_history_with_http_info(self, expense_claim_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an ExpenseClaim  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_expense_claim_history_with_http_info(expense_claim_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expense_claim_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expense_claim_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'expense_claim_id' is set
        if ('expense_claim_id' not in local_var_params or
                local_var_params['expense_claim_id'] is None):
            raise ApiValueError("Missing the required parameter `expense_claim_id` when calling `get_expense_claim_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'expense_claim_id' in local_var_params:
            path_params['ExpenseClaimID'] = local_var_params['expense_claim_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ExpenseClaims/{ExpenseClaimID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_expense_claims(self, **kwargs):  # noqa: E501
        """Allows you to retrieve expense claims  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_expense_claims(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExpenseClaims
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_expense_claims_with_http_info(**kwargs)  # noqa: E501

    def get_expense_claims_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve expense claims  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_expense_claims_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expense_claims" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ExpenseClaims', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExpenseClaims',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified sales invoice or purchase bill  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Invoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_with_http_info(invoice_id, **kwargs)  # noqa: E501

    def get_invoice_with_http_info(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified sales invoice or purchase bill  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_with_http_info(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Invoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice_as_pdf(self, invoice_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve invoices or purchase bills as PDF files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_as_pdf(invoice_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_as_pdf_with_http_info(invoice_id, content_type, **kwargs)  # noqa: E501

    def get_invoice_as_pdf_with_http_info(self, invoice_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve invoices or purchase bills as PDF files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_as_pdf_with_http_info(invoice_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_as_pdf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_invoice_as_pdf`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_invoice_as_pdf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/pdf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice_attachment_by_file_name(self, invoice_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachment on invoices or purchase bills by it's filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_attachment_by_file_name(invoice_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str file_name: Name of the file you are attaching (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_attachment_by_file_name_with_http_info(invoice_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_invoice_attachment_by_file_name_with_http_info(self, invoice_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachment on invoices or purchase bills by it's filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_attachment_by_file_name_with_http_info(invoice_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str file_name: Name of the file you are attaching (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_invoice_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice_attachment_by_id(self, invoice_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_attachment_by_id(invoice_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str attachment_id: Unique identifier for an Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_attachment_by_id_with_http_info(invoice_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_invoice_attachment_by_id_with_http_info(self, invoice_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified Attachment on invoices or purchase bills by it's ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_attachment_by_id_with_http_info(invoice_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str attachment_id: Unique identifier for an Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_invoice_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_invoice_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_invoice_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice_attachments(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_attachments(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_attachments_with_http_info(invoice_id, **kwargs)  # noqa: E501

    def get_invoice_attachments_with_http_info(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_attachments_with_http_info(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_invoice_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice_history(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_history(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_history_with_http_info(invoice_id, **kwargs)  # noqa: E501

    def get_invoice_history_with_http_info(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_history_with_http_info(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_invoice_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoice_reminders(self, **kwargs):  # noqa: E501
        """Allows you to retrieve invoice reminder settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_reminders(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InvoiceReminders
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoice_reminders_with_http_info(**kwargs)  # noqa: E501

    def get_invoice_reminders_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve invoice reminder settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoice_reminders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InvoiceReminders, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoice_reminders" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/InvoiceReminders/Settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InvoiceReminders',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoices(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any sales invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoices(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param str i_ds: Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param str invoice_numbers: Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param str contact_i_ds: Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param str statuses: Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param int page: e.g. page=1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice
        :param bool include_archived: e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response
        :param bool created_by_my_app: When set to true you'll only retrieve Invoices created by your app
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Invoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invoices_with_http_info(**kwargs)  # noqa: E501

    def get_invoices_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any sales invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param str i_ds: Filter by a comma-separated list of InvoicesIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param str invoice_numbers: Filter by a comma-separated list of InvoiceNumbers. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param str contact_i_ds: Filter by a comma-separated list of ContactIDs. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param str statuses: Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
        :param int page: e.g. page=1  Up to 100 invoices will be returned in a single API call with line items shown for each invoice
        :param bool include_archived: e.g. includeArchived=true - Contacts with a status of ARCHIVED will be included in the response
        :param bool created_by_my_app: When set to true you'll only retrieve Invoices created by your app
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'i_ds', 'invoice_numbers', 'contact_i_ds', 'statuses', 'page', 'include_archived', 'created_by_my_app', 'unitdp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoices" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'i_ds' in local_var_params:
            query_params.append(('IDs', local_var_params['i_ds']))  # noqa: E501
        if 'invoice_numbers' in local_var_params:
            query_params.append(('InvoiceNumbers', local_var_params['invoice_numbers']))  # noqa: E501
        if 'contact_i_ds' in local_var_params:
            query_params.append(('ContactIDs', local_var_params['contact_i_ds']))  # noqa: E501
        if 'statuses' in local_var_params:
            query_params.append(('Statuses', local_var_params['statuses']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'include_archived' in local_var_params:
            query_params.append(('includeArchived', local_var_params['include_archived']))  # noqa: E501
        if 'created_by_my_app' in local_var_params:
            query_params.append(('createdByMyApp', local_var_params['created_by_my_app']))  # noqa: E501
        if 'unitdp' in local_var_params:
            query_params.append(('unitdp', local_var_params['unitdp']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Invoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_item(self, item_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_item(item_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Items
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_item_with_http_info(item_id, **kwargs)  # noqa: E501

    def get_item_with_http_info(self, item_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_item_with_http_info(item_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Items, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['item_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_item" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in local_var_params or
                local_var_params['item_id'] is None):
            raise ApiValueError("Missing the required parameter `item_id` when calling `get_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'item_id' in local_var_params:
            path_params['ItemID'] = local_var_params['item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items/{ItemID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Items',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_item_history(self, item_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history for items  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_item_history(item_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_item_history_with_http_info(item_id, **kwargs)  # noqa: E501

    def get_item_history_with_http_info(self, item_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history for items  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_item_history_with_http_info(item_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['item_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_item_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in local_var_params or
                local_var_params['item_id'] is None):
            raise ApiValueError("Missing the required parameter `item_id` when calling `get_item_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'item_id' in local_var_params:
            path_params['ItemID'] = local_var_params['item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items/{ItemID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_items(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any items  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_items(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Items
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_items_with_http_info(**kwargs)  # noqa: E501

    def get_items_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any items  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_items_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Items, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'unitdp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_items" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'unitdp' in local_var_params:
            query_params.append(('unitdp', local_var_params['unitdp']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Items',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_journal(self, journal_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified journals.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_journal(journal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str journal_id: Unique identifier for a Journal (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Journals
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_journal_with_http_info(journal_id, **kwargs)  # noqa: E501

    def get_journal_with_http_info(self, journal_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified journals.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_journal_with_http_info(journal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str journal_id: Unique identifier for a Journal (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Journals, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['journal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_journal" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'journal_id' is set
        if ('journal_id' not in local_var_params or
                local_var_params['journal_id'] is None):
            raise ApiValueError("Missing the required parameter `journal_id` when calling `get_journal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'journal_id' in local_var_params:
            path_params['JournalID'] = local_var_params['journal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Journals/{JournalID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Journals',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_journals(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any journals.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_journals(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param int offset: Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned
        :param bool payments_only: Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Journals
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_journals_with_http_info(**kwargs)  # noqa: E501

    def get_journals_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any journals.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_journals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param int offset: Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned
        :param bool payments_only: Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Journals, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'offset', 'payments_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_journals" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'payments_only' in local_var_params:
            query_params.append(('paymentsOnly', local_var_params['payments_only']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Journals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Journals',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_linked_transaction(self, linked_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_linked_transaction(linked_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LinkedTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_linked_transaction_with_http_info(linked_transaction_id, **kwargs)  # noqa: E501

    def get_linked_transaction_with_http_info(self, linked_transaction_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_linked_transaction_with_http_info(linked_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['linked_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_linked_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'linked_transaction_id' is set
        if ('linked_transaction_id' not in local_var_params or
                local_var_params['linked_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `linked_transaction_id` when calling `get_linked_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'linked_transaction_id' in local_var_params:
            path_params['LinkedTransactionID'] = local_var_params['linked_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LinkedTransactions/{LinkedTransactionID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_linked_transactions(self, **kwargs):  # noqa: E501
        """Retrieve linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_linked_transactions(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page=1.
        :param str linked_transaction_id: The Xero identifier for an Linked Transaction
        :param str source_transaction_id: Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice
        :param str contact_id: Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer.
        :param str status: Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&Status=APPROVED.
        :param str target_transaction_id: Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LinkedTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_linked_transactions_with_http_info(**kwargs)  # noqa: E501

    def get_linked_transactions_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_linked_transactions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page=1.
        :param str linked_transaction_id: The Xero identifier for an Linked Transaction
        :param str source_transaction_id: Filter by the SourceTransactionID. Get all the linked transactions created from a particular ACCPAY invoice
        :param str contact_id: Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer.
        :param str status: Filter by the combination of ContactID and Status. Get all the linked transactions that have been assigned to a particular customer and have a particular status e.g. GET /LinkedTransactions?ContactID=4bb34b03-3378-4bb2-a0ed-6345abf3224e&Status=APPROVED.
        :param str target_transaction_id: Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page', 'linked_transaction_id', 'source_transaction_id', 'contact_id', 'status', 'target_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_linked_transactions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'linked_transaction_id' in local_var_params:
            query_params.append(('LinkedTransactionID', local_var_params['linked_transaction_id']))  # noqa: E501
        if 'source_transaction_id' in local_var_params:
            query_params.append(('SourceTransactionID', local_var_params['source_transaction_id']))  # noqa: E501
        if 'contact_id' in local_var_params:
            query_params.append(('ContactID', local_var_params['contact_id']))  # noqa: E501
        if 'status' in local_var_params:
            query_params.append(('Status', local_var_params['status']))  # noqa: E501
        if 'target_transaction_id' in local_var_params:
            query_params.append(('TargetTransactionID', local_var_params['target_transaction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LinkedTransactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manual_journal(self, manual_journal_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified manual journals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal(manual_journal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ManualJournals
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manual_journal_with_http_info(manual_journal_id, **kwargs)  # noqa: E501

    def get_manual_journal_with_http_info(self, manual_journal_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified manual journals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_with_http_info(manual_journal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `get_manual_journal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManualJournals',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manual_journal_attachment_by_file_name(self, manual_journal_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specified Attachment on ManualJournal by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_attachment_by_file_name(manual_journal_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str file_name: The name of the file being attached to a ManualJournal (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manual_journal_attachment_by_file_name_with_http_info(manual_journal_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_manual_journal_attachment_by_file_name_with_http_info(self, manual_journal_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specified Attachment on ManualJournal by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_attachment_by_file_name_with_http_info(manual_journal_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str file_name: The name of the file being attached to a ManualJournal (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `get_manual_journal_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_manual_journal_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_manual_journal_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manual_journal_attachment_by_id(self, manual_journal_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specified Attachment on ManualJournals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_attachment_by_id(manual_journal_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manual_journal_attachment_by_id_with_http_info(manual_journal_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_manual_journal_attachment_by_id_with_http_info(self, manual_journal_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specified Attachment on ManualJournals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_attachment_by_id_with_http_info(manual_journal_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `get_manual_journal_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_manual_journal_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_manual_journal_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manual_journal_attachments(self, manual_journal_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachment for manual journals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_attachments(manual_journal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manual_journal_attachments_with_http_info(manual_journal_id, **kwargs)  # noqa: E501

    def get_manual_journal_attachments_with_http_info(self, manual_journal_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachment for manual journals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journal_attachments_with_http_info(manual_journal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journal_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `get_manual_journal_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manual_journals(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any manual journals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journals(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ManualJournals
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manual_journals_with_http_info(**kwargs)  # noqa: E501

    def get_manual_journals_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any manual journals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manual_journals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manual_journals" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManualJournals',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_online_invoice(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a URL to an online invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_online_invoice(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OnlineInvoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_online_invoice_with_http_info(invoice_id, **kwargs)  # noqa: E501

    def get_online_invoice_with_http_info(self, invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a URL to an online invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_online_invoice_with_http_info(invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OnlineInvoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_online_invoice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `get_online_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/OnlineInvoice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OnlineInvoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organisation_cis_settings(self, organisation_id, **kwargs):  # noqa: E501
        """Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organisation_cis_settings(organisation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organisation_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CISOrgSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_organisation_cis_settings_with_http_info(organisation_id, **kwargs)  # noqa: E501

    def get_organisation_cis_settings_with_http_info(self, organisation_id, **kwargs):  # noqa: E501
        """Allows you To verify if an organisation is using contruction industry scheme, you can retrieve the CIS settings for the organistaion.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organisation_cis_settings_with_http_info(organisation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organisation_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CISOrgSetting, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['organisation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organisation_cis_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organisation_id' is set
        if ('organisation_id' not in local_var_params or
                local_var_params['organisation_id'] is None):
            raise ApiValueError("Missing the required parameter `organisation_id` when calling `get_organisation_cis_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organisation_id' in local_var_params:
            path_params['OrganisationID'] = local_var_params['organisation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Organisation/{OrganisationID}/CISSettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CISOrgSetting',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organisations(self, **kwargs):  # noqa: E501
        """Allows you to retrieve Organisation details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organisations(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Organisations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_organisations_with_http_info(**kwargs)  # noqa: E501

    def get_organisations_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve Organisation details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organisations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Organisations, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organisations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Organisation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Organisations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_overpayment(self, overpayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified overpayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overpayment(overpayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Overpayments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_overpayment_with_http_info(overpayment_id, **kwargs)  # noqa: E501

    def get_overpayment_with_http_info(self, overpayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified overpayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overpayment_with_http_info(overpayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Overpayments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['overpayment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overpayment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'overpayment_id' is set
        if ('overpayment_id' not in local_var_params or
                local_var_params['overpayment_id'] is None):
            raise ApiValueError("Missing the required parameter `overpayment_id` when calling `get_overpayment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'overpayment_id' in local_var_params:
            path_params['OverpaymentID'] = local_var_params['overpayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Overpayments/{OverpaymentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Overpayments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_overpayment_history(self, overpayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Overpayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overpayment_history(overpayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_overpayment_history_with_http_info(overpayment_id, **kwargs)  # noqa: E501

    def get_overpayment_history_with_http_info(self, overpayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Overpayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overpayment_history_with_http_info(overpayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str overpayment_id: Unique identifier for a Overpayment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['overpayment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overpayment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'overpayment_id' is set
        if ('overpayment_id' not in local_var_params or
                local_var_params['overpayment_id'] is None):
            raise ApiValueError("Missing the required parameter `overpayment_id` when calling `get_overpayment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'overpayment_id' in local_var_params:
            path_params['OverpaymentID'] = local_var_params['overpayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Overpayments/{OverpaymentID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_overpayments(self, **kwargs):  # noqa: E501
        """Allows you to retrieve overpayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overpayments(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Overpayments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_overpayments_with_http_info(**kwargs)  # noqa: E501

    def get_overpayments_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve overpayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overpayments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Overpayments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'page', 'unitdp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overpayments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'unitdp' in local_var_params:
            query_params.append(('unitdp', local_var_params['unitdp']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Overpayments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Overpayments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_payment(self, payment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified payment for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payment(payment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Payments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_payment_with_http_info(payment_id, **kwargs)  # noqa: E501

    def get_payment_with_http_info(self, payment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified payment for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payment_with_http_info(payment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['payment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'payment_id' is set
        if ('payment_id' not in local_var_params or
                local_var_params['payment_id'] is None):
            raise ApiValueError("Missing the required parameter `payment_id` when calling `get_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'payment_id' in local_var_params:
            path_params['PaymentID'] = local_var_params['payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Payments/{PaymentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Payments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_payment_history(self, payment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history records of a payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payment_history(payment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_payment_history_with_http_info(payment_id, **kwargs)  # noqa: E501

    def get_payment_history_with_http_info(self, payment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history records of a payment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payment_history_with_http_info(payment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str payment_id: Unique identifier for a Payment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['payment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'payment_id' is set
        if ('payment_id' not in local_var_params or
                local_var_params['payment_id'] is None):
            raise ApiValueError("Missing the required parameter `payment_id` when calling `get_payment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'payment_id' in local_var_params:
            path_params['PaymentID'] = local_var_params['payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Payments/{PaymentID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_payment_services(self, **kwargs):  # noqa: E501
        """Allows you to retrieve payment services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payment_services(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaymentServices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_payment_services_with_http_info(**kwargs)  # noqa: E501

    def get_payment_services_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve payment services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payment_services_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaymentServices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payment_services" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PaymentServices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaymentServices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_payments(self, **kwargs):  # noqa: E501
        """Allows you to retrieve payments for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payments(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Payments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_payments_with_http_info(**kwargs)  # noqa: E501

    def get_payments_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve payments for invoices and credit notes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_payments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Payments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_payments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Payments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Payments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prepayment(self, prepayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified prepayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prepayment(prepayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: Unique identifier for a PrePayment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Prepayments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_prepayment_with_http_info(prepayment_id, **kwargs)  # noqa: E501

    def get_prepayment_with_http_info(self, prepayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified prepayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prepayment_with_http_info(prepayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: Unique identifier for a PrePayment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Prepayments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['prepayment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prepayment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'prepayment_id' is set
        if ('prepayment_id' not in local_var_params or
                local_var_params['prepayment_id'] is None):
            raise ApiValueError("Missing the required parameter `prepayment_id` when calling `get_prepayment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'prepayment_id' in local_var_params:
            path_params['PrepaymentID'] = local_var_params['prepayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Prepayments/{PrepaymentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prepayments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prepayment_history(self, prepayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Prepayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prepayment_history(prepayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: Unique identifier for a PrePayment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_prepayment_history_with_http_info(prepayment_id, **kwargs)  # noqa: E501

    def get_prepayment_history_with_http_info(self, prepayment_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Prepayment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prepayment_history_with_http_info(prepayment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str prepayment_id: Unique identifier for a PrePayment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['prepayment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prepayment_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'prepayment_id' is set
        if ('prepayment_id' not in local_var_params or
                local_var_params['prepayment_id'] is None):
            raise ApiValueError("Missing the required parameter `prepayment_id` when calling `get_prepayment_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'prepayment_id' in local_var_params:
            path_params['PrepaymentID'] = local_var_params['prepayment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Prepayments/{PrepaymentID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prepayments(self, **kwargs):  # noqa: E501
        """Allows you to retrieve prepayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prepayments(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Prepayments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_prepayments_with_http_info(**kwargs)  # noqa: E501

    def get_prepayments_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve prepayments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prepayments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int page: e.g. page=1  Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Prepayments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'page', 'unitdp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prepayments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'unitdp' in local_var_params:
            query_params.append(('unitdp', local_var_params['unitdp']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Prepayments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prepayments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_purchase_order(self, purchase_order_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_purchase_order(purchase_order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PurchaseOrders
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_purchase_order_with_http_info(purchase_order_id, **kwargs)  # noqa: E501

    def get_purchase_order_with_http_info(self, purchase_order_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_purchase_order_with_http_info(purchase_order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['purchase_order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'purchase_order_id' is set
        if ('purchase_order_id' not in local_var_params or
                local_var_params['purchase_order_id'] is None):
            raise ApiValueError("Missing the required parameter `purchase_order_id` when calling `get_purchase_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'purchase_order_id' in local_var_params:
            path_params['PurchaseOrderID'] = local_var_params['purchase_order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PurchaseOrders/{PurchaseOrderID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PurchaseOrders',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_purchase_order_history(self, purchase_order_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history for PurchaseOrder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_purchase_order_history(purchase_order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_purchase_order_history_with_http_info(purchase_order_id, **kwargs)  # noqa: E501

    def get_purchase_order_history_with_http_info(self, purchase_order_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history for PurchaseOrder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_purchase_order_history_with_http_info(purchase_order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['purchase_order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_order_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'purchase_order_id' is set
        if ('purchase_order_id' not in local_var_params or
                local_var_params['purchase_order_id'] is None):
            raise ApiValueError("Missing the required parameter `purchase_order_id` when calling `get_purchase_order_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'purchase_order_id' in local_var_params:
            path_params['PurchaseOrderID'] = local_var_params['purchase_order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PurchaseOrders/{PurchaseOrderID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_purchase_orders(self, **kwargs):  # noqa: E501
        """Allows you to retrieve purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_purchase_orders(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str status: Filter by purchase order status
        :param str date_from: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :param str date_to: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :param str order: Order by an any element
        :param int page: To specify a page, append the page parameter to the URL e.g. ?page=1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page=2 and continuing this process until no more results are returned.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PurchaseOrders
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_purchase_orders_with_http_info(**kwargs)  # noqa: E501

    def get_purchase_orders_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve purchase orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_purchase_orders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str status: Filter by purchase order status
        :param str date_from: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :param str date_to: Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom=2015-12-01&DateTo=2015-12-31
        :param str order: Order by an any element
        :param int page: To specify a page, append the page parameter to the URL e.g. ?page=1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page=2 and continuing this process until no more results are returned.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'status', 'date_from', 'date_to', 'order', 'page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_purchase_orders" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in local_var_params:
            query_params.append(('Status', local_var_params['status']))  # noqa: E501
        if 'date_from' in local_var_params:
            query_params.append(('DateFrom', local_var_params['date_from']))  # noqa: E501
        if 'date_to' in local_var_params:
            query_params.append(('DateTo', local_var_params['date_to']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PurchaseOrders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PurchaseOrders',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_receipt(self, receipt_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified draft expense claim receipts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt(receipt_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Receipts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_receipt_with_http_info(receipt_id, **kwargs)  # noqa: E501

    def get_receipt_with_http_info(self, receipt_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified draft expense claim receipts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_with_http_info(receipt_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `get_receipt`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Receipts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_receipt_attachment_by_file_name(self, receipt_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on expense claim receipts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_attachment_by_file_name(receipt_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str file_name: The name of the file being attached to the Receipt (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_receipt_attachment_by_file_name_with_http_info(receipt_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_receipt_attachment_by_file_name_with_http_info(self, receipt_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on expense claim receipts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_attachment_by_file_name_with_http_info(receipt_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str file_name: The name of the file being attached to the Receipt (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `get_receipt_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_receipt_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_receipt_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_receipt_attachment_by_id(self, receipt_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on expense claim receipts by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_attachment_by_id(receipt_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_receipt_attachment_by_id_with_http_info(receipt_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_receipt_attachment_by_id_with_http_info(self, receipt_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on expense claim receipts by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_attachment_by_id_with_http_info(receipt_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `get_receipt_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_receipt_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_receipt_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_receipt_attachments(self, receipt_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments for expense claim receipts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_attachments(receipt_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_receipt_attachments_with_http_info(receipt_id, **kwargs)  # noqa: E501

    def get_receipt_attachments_with_http_info(self, receipt_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments for expense claim receipts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_attachments_with_http_info(receipt_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `get_receipt_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_receipt_history(self, receipt_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Receipt  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_history(receipt_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_receipt_history_with_http_info(receipt_id, **kwargs)  # noqa: E501

    def get_receipt_history_with_http_info(self, receipt_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a history records of an Receipt  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipt_history_with_http_info(receipt_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipt_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `get_receipt_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_receipts(self, **kwargs):  # noqa: E501
        """Allows you to retrieve draft expense claim receipts for any user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipts(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Receipts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_receipts_with_http_info(**kwargs)  # noqa: E501

    def get_receipts_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve draft expense claim receipts for any user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_receipts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param int unitdp: e.g. unitdp=4  You can opt in to use four decimal places for unit amounts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order', 'unitdp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_receipts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'unitdp' in local_var_params:
            query_params.append(('unitdp', local_var_params['unitdp']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Receipts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repeating_invoice(self, repeating_invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice(repeating_invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RepeatingInvoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repeating_invoice_with_http_info(repeating_invoice_id, **kwargs)  # noqa: E501

    def get_repeating_invoice_with_http_info(self, repeating_invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_with_http_info(repeating_invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `get_repeating_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepeatingInvoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repeating_invoice_attachment_by_file_name(self, repeating_invoice_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specified attachment on repeating invoices by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_attachment_by_file_name(repeating_invoice_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str file_name: The name of the file being attached to a Repeating Invoice (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repeating_invoice_attachment_by_file_name_with_http_info(repeating_invoice_id, file_name, content_type, **kwargs)  # noqa: E501

    def get_repeating_invoice_attachment_by_file_name_with_http_info(self, repeating_invoice_id, file_name, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve specified attachment on repeating invoices by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_attachment_by_file_name_with_http_info(repeating_invoice_id, file_name, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str file_name: The name of the file being attached to a Repeating Invoice (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id', 'file_name', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `get_repeating_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `get_repeating_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_repeating_invoice_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repeating_invoice_attachment_by_id(self, repeating_invoice_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified Attachments on repeating invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_attachment_by_id(repeating_invoice_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repeating_invoice_attachment_by_id_with_http_info(repeating_invoice_id, attachment_id, content_type, **kwargs)  # noqa: E501

    def get_repeating_invoice_attachment_by_id_with_http_info(self, repeating_invoice_id, attachment_id, content_type, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified Attachments on repeating invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_attachment_by_id_with_http_info(repeating_invoice_id, attachment_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str attachment_id: Unique identifier for a Attachment (required)
        :param str content_type: The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id', 'attachment_id', 'content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_attachment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `get_repeating_invoice_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'attachment_id' is set
        if ('attachment_id' not in local_var_params or
                local_var_params['attachment_id'] is None):
            raise ApiValueError("Missing the required parameter `attachment_id` when calling `get_repeating_invoice_attachment_by_id`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_repeating_invoice_attachment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501
        if 'attachment_id' in local_var_params:
            path_params['AttachmentID'] = local_var_params['attachment_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['contentType'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repeating_invoice_attachments(self, repeating_invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_attachments(repeating_invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repeating_invoice_attachments_with_http_info(repeating_invoice_id, **kwargs)  # noqa: E501

    def get_repeating_invoice_attachments_with_http_info(self, repeating_invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve Attachments on repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_attachments_with_http_info(repeating_invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_attachments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `get_repeating_invoice_attachments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repeating_invoice_history(self, repeating_invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history for a repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_history(repeating_invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HistoryRecords
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repeating_invoice_history_with_http_info(repeating_invoice_id, **kwargs)  # noqa: E501

    def get_repeating_invoice_history_with_http_info(self, repeating_invoice_id, **kwargs):  # noqa: E501
        """Allows you to retrieve history for a repeating invoice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoice_history_with_http_info(repeating_invoice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HistoryRecords, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoice_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `get_repeating_invoice_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/History', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryRecords',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repeating_invoices(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any repeating invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoices(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RepeatingInvoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repeating_invoices_with_http_info(**kwargs)  # noqa: E501

    def get_repeating_invoices_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve any repeating invoices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repeating_invoices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RepeatingInvoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repeating_invoices" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepeatingInvoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_aged_payables_by_contact(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve report for AgedPayablesByContact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_aged_payables_by_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param date date: The date of the Aged Payables By Contact report
        :param date from_date: The from date of the Aged Payables By Contact report
        :param date to_date: The to date of the Aged Payables By Contact report
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_aged_payables_by_contact_with_http_info(contact_id, **kwargs)  # noqa: E501

    def get_report_aged_payables_by_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve report for AgedPayablesByContact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_aged_payables_by_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param date date: The date of the Aged Payables By Contact report
        :param date from_date: The from date of the Aged Payables By Contact report
        :param date to_date: The to date of the Aged Payables By Contact report
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'date', 'from_date', 'to_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_aged_payables_by_contact" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_report_aged_payables_by_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contact_id' in local_var_params:
            query_params.append(('contactId', local_var_params['contact_id']))  # noqa: E501
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501
        if 'from_date' in local_var_params:
            query_params.append(('fromDate', local_var_params['from_date']))  # noqa: E501
        if 'to_date' in local_var_params:
            query_params.append(('toDate', local_var_params['to_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/AgedPayablesByContact', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_aged_receivables_by_contact(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve report for AgedReceivablesByContact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_aged_receivables_by_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param date date: The date of the Aged Receivables By Contact report
        :param date from_date: The from date of the Aged Receivables By Contact report
        :param date to_date: The to date of the Aged Receivables By Contact report
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_aged_receivables_by_contact_with_http_info(contact_id, **kwargs)  # noqa: E501

    def get_report_aged_receivables_by_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Allows you to retrieve report for AgedReceivablesByContact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_aged_receivables_by_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param date date: The date of the Aged Receivables By Contact report
        :param date from_date: The from date of the Aged Receivables By Contact report
        :param date to_date: The to date of the Aged Receivables By Contact report
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'date', 'from_date', 'to_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_aged_receivables_by_contact" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `get_report_aged_receivables_by_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contact_id' in local_var_params:
            query_params.append(('contactId', local_var_params['contact_id']))  # noqa: E501
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501
        if 'from_date' in local_var_params:
            query_params.append(('fromDate', local_var_params['from_date']))  # noqa: E501
        if 'to_date' in local_var_params:
            query_params.append(('toDate', local_var_params['to_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/AgedReceivablesByContact', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_ba_sor_gst(self, report_id, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BAS only valid for AU orgs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_ba_sor_gst(report_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str report_id: Unique identifier for a Report (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_ba_sor_gst_with_http_info(report_id, **kwargs)  # noqa: E501

    def get_report_ba_sor_gst_with_http_info(self, report_id, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BAS only valid for AU orgs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_ba_sor_gst_with_http_info(report_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str report_id: Unique identifier for a Report (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['report_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_ba_sor_gst" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'report_id' is set
        if ('report_id' not in local_var_params or
                local_var_params['report_id'] is None):
            raise ApiValueError("Missing the required parameter `report_id` when calling `get_report_ba_sor_gst`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'report_id' in local_var_params:
            path_params['ReportID'] = local_var_params['report_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/{ReportID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_ba_sor_gst_list(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BAS only valid for AU orgs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_ba_sor_gst_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_ba_sor_gst_list_with_http_info(**kwargs)  # noqa: E501

    def get_report_ba_sor_gst_list_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BAS only valid for AU orgs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_ba_sor_gst_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_ba_sor_gst_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_balance_sheet(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BalanceSheet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_balance_sheet(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str date: The date of the Balance Sheet report
        :param int periods: The number of periods for the Balance Sheet report
        :param str timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :param str tracking_option_id1: The tracking option 1 for the Balance Sheet report
        :param str tracking_option_id2: The tracking option 2 for the Balance Sheet report
        :param bool standard_layout: The standard layout boolean for the Balance Sheet report
        :param bool payments_only: return a cash basis for the Balance Sheet report
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_balance_sheet_with_http_info(**kwargs)  # noqa: E501

    def get_report_balance_sheet_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BalanceSheet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_balance_sheet_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str date: The date of the Balance Sheet report
        :param int periods: The number of periods for the Balance Sheet report
        :param str timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :param str tracking_option_id1: The tracking option 1 for the Balance Sheet report
        :param str tracking_option_id2: The tracking option 2 for the Balance Sheet report
        :param bool standard_layout: The standard layout boolean for the Balance Sheet report
        :param bool payments_only: return a cash basis for the Balance Sheet report
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['date', 'periods', 'timeframe', 'tracking_option_id1', 'tracking_option_id2', 'standard_layout', 'payments_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_balance_sheet" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501
        if 'periods' in local_var_params:
            query_params.append(('periods', local_var_params['periods']))  # noqa: E501
        if 'timeframe' in local_var_params:
            query_params.append(('timeframe', local_var_params['timeframe']))  # noqa: E501
        if 'tracking_option_id1' in local_var_params:
            query_params.append(('trackingOptionID1', local_var_params['tracking_option_id1']))  # noqa: E501
        if 'tracking_option_id2' in local_var_params:
            query_params.append(('trackingOptionID2', local_var_params['tracking_option_id2']))  # noqa: E501
        if 'standard_layout' in local_var_params:
            query_params.append(('standardLayout', local_var_params['standard_layout']))  # noqa: E501
        if 'payments_only' in local_var_params:
            query_params.append(('paymentsOnly', local_var_params['payments_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/BalanceSheet', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_bank_summary(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BankSummary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_bank_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Bank Summary report e.g. 2018-03-31
        :param int period: The number of periods to compare (integer between 1 and 12)
        :param int timeframe: The period size to compare to (1=month, 3=quarter, 12=year)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_bank_summary_with_http_info(**kwargs)  # noqa: E501

    def get_report_bank_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for BankSummary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_bank_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Bank Summary report e.g. 2018-03-31
        :param int period: The number of periods to compare (integer between 1 and 12)
        :param int timeframe: The period size to compare to (1=month, 3=quarter, 12=year)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['date', 'period', 'timeframe']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_bank_summary" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'timeframe' in local_var_params:
            query_params.append(('timeframe', local_var_params['timeframe']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/BankSummary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_budget_summary(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for Budget Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_budget_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Bank Summary report e.g. 2018-03-31
        :param int period: The number of periods to compare (integer between 1 and 12)
        :param int timeframe: The period size to compare to (1=month, 3=quarter, 12=year)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_budget_summary_with_http_info(**kwargs)  # noqa: E501

    def get_report_budget_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for Budget Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_budget_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Bank Summary report e.g. 2018-03-31
        :param int period: The number of periods to compare (integer between 1 and 12)
        :param int timeframe: The period size to compare to (1=month, 3=quarter, 12=year)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['date', 'period', 'timeframe']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_budget_summary" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'timeframe' in local_var_params:
            query_params.append(('timeframe', local_var_params['timeframe']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/BudgetSummary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_executive_summary(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for ExecutiveSummary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_executive_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Bank Summary report e.g. 2018-03-31
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_executive_summary_with_http_info(**kwargs)  # noqa: E501

    def get_report_executive_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for ExecutiveSummary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_executive_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Bank Summary report e.g. 2018-03-31
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_executive_summary" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/ExecutiveSummary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_profit_and_loss(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for ProfitAndLoss  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_profit_and_loss(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date from_date: The from date for the ProfitAndLoss report e.g. 2018-03-31
        :param date to_date: The to date for the ProfitAndLoss report e.g. 2018-03-31
        :param int periods: The number of periods to compare (integer between 1 and 12)
        :param str timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :param str tracking_category_id: The trackingCategory 1 for the ProfitAndLoss report
        :param str tracking_category_id2: The trackingCategory 2 for the ProfitAndLoss report
        :param str tracking_option_id: The tracking option 1 for the ProfitAndLoss report
        :param str tracking_option_id2: The tracking option 2 for the ProfitAndLoss report
        :param bool standard_layout: Return the standard layout for the ProfitAndLoss report
        :param bool payments_only: Return cash only basis for the ProfitAndLoss report
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_profit_and_loss_with_http_info(**kwargs)  # noqa: E501

    def get_report_profit_and_loss_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for ProfitAndLoss  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_profit_and_loss_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date from_date: The from date for the ProfitAndLoss report e.g. 2018-03-31
        :param date to_date: The to date for the ProfitAndLoss report e.g. 2018-03-31
        :param int periods: The number of periods to compare (integer between 1 and 12)
        :param str timeframe: The period size to compare to (MONTH, QUARTER, YEAR)
        :param str tracking_category_id: The trackingCategory 1 for the ProfitAndLoss report
        :param str tracking_category_id2: The trackingCategory 2 for the ProfitAndLoss report
        :param str tracking_option_id: The tracking option 1 for the ProfitAndLoss report
        :param str tracking_option_id2: The tracking option 2 for the ProfitAndLoss report
        :param bool standard_layout: Return the standard layout for the ProfitAndLoss report
        :param bool payments_only: Return cash only basis for the ProfitAndLoss report
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['from_date', 'to_date', 'periods', 'timeframe', 'tracking_category_id', 'tracking_category_id2', 'tracking_option_id', 'tracking_option_id2', 'standard_layout', 'payments_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_profit_and_loss" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_date' in local_var_params:
            query_params.append(('fromDate', local_var_params['from_date']))  # noqa: E501
        if 'to_date' in local_var_params:
            query_params.append(('toDate', local_var_params['to_date']))  # noqa: E501
        if 'periods' in local_var_params:
            query_params.append(('periods', local_var_params['periods']))  # noqa: E501
        if 'timeframe' in local_var_params:
            query_params.append(('timeframe', local_var_params['timeframe']))  # noqa: E501
        if 'tracking_category_id' in local_var_params:
            query_params.append(('trackingCategoryID', local_var_params['tracking_category_id']))  # noqa: E501
        if 'tracking_category_id2' in local_var_params:
            query_params.append(('trackingCategoryID2', local_var_params['tracking_category_id2']))  # noqa: E501
        if 'tracking_option_id' in local_var_params:
            query_params.append(('trackingOptionID', local_var_params['tracking_option_id']))  # noqa: E501
        if 'tracking_option_id2' in local_var_params:
            query_params.append(('trackingOptionID2', local_var_params['tracking_option_id2']))  # noqa: E501
        if 'standard_layout' in local_var_params:
            query_params.append(('standardLayout', local_var_params['standard_layout']))  # noqa: E501
        if 'payments_only' in local_var_params:
            query_params.append(('paymentsOnly', local_var_params['payments_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/ProfitAndLoss', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_ten_ninety_nine(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for TenNinetyNine  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_ten_ninety_nine(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str report_year: The year of the 1099 report
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Reports
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_ten_ninety_nine_with_http_info(**kwargs)  # noqa: E501

    def get_report_ten_ninety_nine_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for TenNinetyNine  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_ten_ninety_nine_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str report_year: The year of the 1099 report
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Reports, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['report_year']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_ten_ninety_nine" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'report_year' in local_var_params:
            query_params.append(('reportYear', local_var_params['report_year']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/TenNinetyNine', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Reports',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_trial_balance(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for TrialBalance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_trial_balance(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Trial Balance report e.g. 2018-03-31
        :param bool payments_only: Return cash only basis for the Trial Balance report
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReportWithRows
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_report_trial_balance_with_http_info(**kwargs)  # noqa: E501

    def get_report_trial_balance_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve report for TrialBalance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_trial_balance_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date date: The date for the Trial Balance report e.g. 2018-03-31
        :param bool payments_only: Return cash only basis for the Trial Balance report
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReportWithRows, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['date', 'payments_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_trial_balance" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date' in local_var_params:
            query_params.append(('date', local_var_params['date']))  # noqa: E501
        if 'payments_only' in local_var_params:
            query_params.append(('paymentsOnly', local_var_params['payments_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Reports/TrialBalance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportWithRows',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tax_rates(self, **kwargs):  # noqa: E501
        """Allows you to retrieve Tax Rates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tax_rates(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param str tax_type: Filter by tax type
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaxRates
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tax_rates_with_http_info(**kwargs)  # noqa: E501

    def get_tax_rates_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve Tax Rates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tax_rates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param str tax_type: Filter by tax type
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['where', 'order', 'tax_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tax_rates" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'tax_type' in local_var_params:
            query_params.append(('TaxType', local_var_params['tax_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TaxRates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaxRates',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tracking_categories(self, **kwargs):  # noqa: E501
        """Allows you to retrieve tracking categories and options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tracking_categories(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param bool include_archived: e.g. includeArchived=true - Categories and options with a status of ARCHIVED will be included in the response
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingCategories
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tracking_categories_with_http_info(**kwargs)  # noqa: E501

    def get_tracking_categories_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve tracking categories and options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tracking_categories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param bool include_archived: e.g. includeArchived=true - Categories and options with a status of ARCHIVED will be included in the response
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['where', 'order', 'include_archived']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tracking_categories" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'include_archived' in local_var_params:
            query_params.append(('includeArchived', local_var_params['include_archived']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingCategories',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tracking_category(self, tracking_category_id, **kwargs):  # noqa: E501
        """Allows you to retrieve tracking categories and options for specified category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tracking_category(tracking_category_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingCategories
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tracking_category_with_http_info(tracking_category_id, **kwargs)  # noqa: E501

    def get_tracking_category_with_http_info(self, tracking_category_id, **kwargs):  # noqa: E501
        """Allows you to retrieve tracking categories and options for specified category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tracking_category_with_http_info(tracking_category_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tracking_category_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tracking_category" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tracking_category_id' is set
        if ('tracking_category_id' not in local_var_params or
                local_var_params['tracking_category_id'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category_id` when calling `get_tracking_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tracking_category_id' in local_var_params:
            path_params['TrackingCategoryID'] = local_var_params['tracking_category_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories/{TrackingCategoryID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingCategories',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, user_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: Unique identifier for a User (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Users
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501

    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: Unique identifier for a User (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Users, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in local_var_params or
                local_var_params['user_id'] is None):
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['UserID'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Users/{UserID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Users',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """Allows you to retrieve users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Users
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_with_http_info(**kwargs)  # noqa: E501

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """Allows you to retrieve users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime if_modified_since: Only records created or modified since this timestamp will be returned
        :param str where: Filter by an any element
        :param str order: Order by an any element
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Users, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['if_modified_since', 'where', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'where' in local_var_params:
            query_params.append(('where', local_var_params['where']))  # noqa: E501
        if 'order' in local_var_params:
            query_params.append(('order', local_var_params['order']))  # noqa: E501

        header_params = {}
        if 'if_modified_since' in local_var_params:
            header_params['If-Modified-Since'] = local_var_params['if_modified_since']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Users',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account(self, account_id, accounts, **kwargs):  # noqa: E501
        """Allows you to update a chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account(account_id, accounts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for retrieving single object (required)
        :param Accounts accounts: Request of type Accounts array with one Account (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Accounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_account_with_http_info(account_id, accounts, **kwargs)  # noqa: E501

    def update_account_with_http_info(self, account_id, accounts, **kwargs):  # noqa: E501
        """Allows you to update a chart of accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_with_http_info(account_id, accounts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for retrieving single object (required)
        :param Accounts accounts: Request of type Accounts array with one Account (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Accounts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id', 'accounts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `update_account`")  # noqa: E501
        # verify the required parameter 'accounts' is set
        if ('accounts' not in local_var_params or
                local_var_params['accounts'] is None):
            raise ApiValueError("Missing the required parameter `accounts` when calling `update_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'accounts' in local_var_params:
            body_params = local_var_params['accounts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Accounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account_attachment_by_file_name(self, account_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachment on Account by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_attachment_by_file_name(account_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str file_name: Name of the attachment (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_account_attachment_by_file_name_with_http_info(account_id, file_name, body, **kwargs)  # noqa: E501

    def update_account_attachment_by_file_name_with_http_info(self, account_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachment on Account by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_attachment_by_file_name_with_http_info(account_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str account_id: Unique identifier for Account object (required)
        :param str file_name: Name of the attachment (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in local_var_params or
                local_var_params['account_id'] is None):
            raise ApiValueError("Missing the required parameter `account_id` when calling `update_account_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_account_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_account_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['AccountID'] = local_var_params['account_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Accounts/{AccountID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bank_transaction(self, bank_transaction_id, bank_transactions, **kwargs):  # noqa: E501
        """Allows you to update a single spend or receive money transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_transaction(bank_transaction_id, bank_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param BankTransactions bank_transactions: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BankTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_bank_transaction_with_http_info(bank_transaction_id, bank_transactions, **kwargs)  # noqa: E501

    def update_bank_transaction_with_http_info(self, bank_transaction_id, bank_transactions, **kwargs):  # noqa: E501
        """Allows you to update a single spend or receive money transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_transaction_with_http_info(bank_transaction_id, bank_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param BankTransactions bank_transactions: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BankTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id', 'bank_transactions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `update_bank_transaction`")  # noqa: E501
        # verify the required parameter 'bank_transactions' is set
        if ('bank_transactions' not in local_var_params or
                local_var_params['bank_transactions'] is None):
            raise ApiValueError("Missing the required parameter `bank_transactions` when calling `update_bank_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bank_transactions' in local_var_params:
            body_params = local_var_params['bank_transactions']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BankTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bank_transaction_attachment_by_file_name(self, bank_transaction_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update an Attachment on BankTransaction by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_transaction_attachment_by_file_name(bank_transaction_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str file_name: The name of the file being attached (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_bank_transaction_attachment_by_file_name_with_http_info(bank_transaction_id, file_name, body, **kwargs)  # noqa: E501

    def update_bank_transaction_attachment_by_file_name_with_http_info(self, bank_transaction_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update an Attachment on BankTransaction by Filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_transaction_attachment_by_file_name_with_http_info(bank_transaction_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transaction_id: Xero generated unique identifier for a bank transaction (required)
        :param str file_name: The name of the file being attached (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transaction_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_transaction_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transaction_id' is set
        if ('bank_transaction_id' not in local_var_params or
                local_var_params['bank_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transaction_id` when calling `update_bank_transaction_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_bank_transaction_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_bank_transaction_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transaction_id' in local_var_params:
            path_params['BankTransactionID'] = local_var_params['bank_transaction_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransactions/{BankTransactionID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bank_transfer_attachment_by_file_name(self, bank_transfer_id, file_name, body, **kwargs):  # noqa: E501
        """update_bank_transfer_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_transfer_attachment_by_file_name(bank_transfer_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str file_name: The name of the file being attached to a Bank Transfer (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_bank_transfer_attachment_by_file_name_with_http_info(bank_transfer_id, file_name, body, **kwargs)  # noqa: E501

    def update_bank_transfer_attachment_by_file_name_with_http_info(self, bank_transfer_id, file_name, body, **kwargs):  # noqa: E501
        """update_bank_transfer_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_transfer_attachment_by_file_name_with_http_info(bank_transfer_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str bank_transfer_id: Xero generated unique identifier for a bank transfer (required)
        :param str file_name: The name of the file being attached to a Bank Transfer (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['bank_transfer_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_transfer_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'bank_transfer_id' is set
        if ('bank_transfer_id' not in local_var_params or
                local_var_params['bank_transfer_id'] is None):
            raise ApiValueError("Missing the required parameter `bank_transfer_id` when calling `update_bank_transfer_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_bank_transfer_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_bank_transfer_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_transfer_id' in local_var_params:
            path_params['BankTransferID'] = local_var_params['bank_transfer_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/BankTransfers/{BankTransferID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact(self, contact_id, **kwargs):  # noqa: E501
        """update_contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param Contacts contacts:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Contacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_contact_with_http_info(contact_id, **kwargs)  # noqa: E501

    def update_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """update_contact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param Contacts contacts:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Contacts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'contacts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `update_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contacts' in local_var_params:
            body_params = local_var_params['contacts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact_attachment_by_file_name(self, contact_id, file_name, body, **kwargs):  # noqa: E501
        """update_contact_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_attachment_by_file_name(contact_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str file_name: Name for the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_contact_attachment_by_file_name_with_http_info(contact_id, file_name, body, **kwargs)  # noqa: E501

    def update_contact_attachment_by_file_name_with_http_info(self, contact_id, file_name, body, **kwargs):  # noqa: E501
        """update_contact_attachment_by_file_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_attachment_by_file_name_with_http_info(contact_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_id: Unique identifier for a Contact (required)
        :param str file_name: Name for the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in local_var_params or
                local_var_params['contact_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_id` when calling `update_contact_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_contact_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_contact_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in local_var_params:
            path_params['ContactID'] = local_var_params['contact_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Contacts/{ContactID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact_group(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to update a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_group(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param ContactGroups contact_groups:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ContactGroups
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_contact_group_with_http_info(contact_group_id, **kwargs)  # noqa: E501

    def update_contact_group_with_http_info(self, contact_group_id, **kwargs):  # noqa: E501
        """Allows you to update a Contract Group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_group_with_http_info(contact_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contact_group_id: Unique identifier for a Contact Group (required)
        :param ContactGroups contact_groups:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ContactGroups, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['contact_group_id', 'contact_groups']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contact_group_id' is set
        if ('contact_group_id' not in local_var_params or
                local_var_params['contact_group_id'] is None):
            raise ApiValueError("Missing the required parameter `contact_group_id` when calling `update_contact_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_group_id' in local_var_params:
            path_params['ContactGroupID'] = local_var_params['contact_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact_groups' in local_var_params:
            body_params = local_var_params['contact_groups']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ContactGroups/{ContactGroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactGroups',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_credit_note(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to update a specific credit note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_credit_note(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param CreditNotes credit_notes:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreditNotes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_credit_note_with_http_info(credit_note_id, **kwargs)  # noqa: E501

    def update_credit_note_with_http_info(self, credit_note_id, **kwargs):  # noqa: E501
        """Allows you to update a specific credit note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_credit_note_with_http_info(credit_note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param CreditNotes credit_notes:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreditNotes, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'credit_notes']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_credit_note" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `update_credit_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'credit_notes' in local_var_params:
            body_params = local_var_params['credit_notes']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreditNotes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_credit_note_attachment_by_file_name(self, credit_note_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachments on CreditNote by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_credit_note_attachment_by_file_name(credit_note_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str file_name: Name of the file you are attaching to Credit Note (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_credit_note_attachment_by_file_name_with_http_info(credit_note_id, file_name, body, **kwargs)  # noqa: E501

    def update_credit_note_attachment_by_file_name_with_http_info(self, credit_note_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachments on CreditNote by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_credit_note_attachment_by_file_name_with_http_info(credit_note_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str credit_note_id: Unique identifier for a Credit Note (required)
        :param str file_name: Name of the file you are attaching to Credit Note (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credit_note_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_credit_note_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credit_note_id' is set
        if ('credit_note_id' not in local_var_params or
                local_var_params['credit_note_id'] is None):
            raise ApiValueError("Missing the required parameter `credit_note_id` when calling `update_credit_note_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_credit_note_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_credit_note_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_note_id' in local_var_params:
            path_params['CreditNoteID'] = local_var_params['credit_note_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/CreditNotes/{CreditNoteID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_employee(self, employee_id, employees, **kwargs):  # noqa: E501
        """Allows you to update a specific employee used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_employee(employee_id, employees, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str employee_id: Unique identifier for a Employee (required)
        :param Employees employees: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Employees
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_employee_with_http_info(employee_id, employees, **kwargs)  # noqa: E501

    def update_employee_with_http_info(self, employee_id, employees, **kwargs):  # noqa: E501
        """Allows you to update a specific employee used in Xero payrun  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_employee_with_http_info(employee_id, employees, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str employee_id: Unique identifier for a Employee (required)
        :param Employees employees: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Employees, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['employee_id', 'employees']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_employee" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'employee_id' is set
        if ('employee_id' not in local_var_params or
                local_var_params['employee_id'] is None):
            raise ApiValueError("Missing the required parameter `employee_id` when calling `update_employee`")  # noqa: E501
        # verify the required parameter 'employees' is set
        if ('employees' not in local_var_params or
                local_var_params['employees'] is None):
            raise ApiValueError("Missing the required parameter `employees` when calling `update_employee`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'employee_id' in local_var_params:
            path_params['EmployeeID'] = local_var_params['employee_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'employees' in local_var_params:
            body_params = local_var_params['employees']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Employees/{EmployeeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Employees',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_expense_claim(self, expense_claim_id, expense_claims, **kwargs):  # noqa: E501
        """Allows you to update specified expense claims  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_expense_claim(expense_claim_id, expense_claims, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param ExpenseClaims expense_claims: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExpenseClaims
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_expense_claim_with_http_info(expense_claim_id, expense_claims, **kwargs)  # noqa: E501

    def update_expense_claim_with_http_info(self, expense_claim_id, expense_claims, **kwargs):  # noqa: E501
        """Allows you to update specified expense claims  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_expense_claim_with_http_info(expense_claim_id, expense_claims, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str expense_claim_id: Unique identifier for a ExpenseClaim (required)
        :param ExpenseClaims expense_claims: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExpenseClaims, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['expense_claim_id', 'expense_claims']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_expense_claim" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'expense_claim_id' is set
        if ('expense_claim_id' not in local_var_params or
                local_var_params['expense_claim_id'] is None):
            raise ApiValueError("Missing the required parameter `expense_claim_id` when calling `update_expense_claim`")  # noqa: E501
        # verify the required parameter 'expense_claims' is set
        if ('expense_claims' not in local_var_params or
                local_var_params['expense_claims'] is None):
            raise ApiValueError("Missing the required parameter `expense_claims` when calling `update_expense_claim`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'expense_claim_id' in local_var_params:
            path_params['ExpenseClaimID'] = local_var_params['expense_claim_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'expense_claims' in local_var_params:
            body_params = local_var_params['expense_claims']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ExpenseClaims/{ExpenseClaimID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExpenseClaims',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_invoice(self, invoice_id, invoices, **kwargs):  # noqa: E501
        """Allows you to update a specified sales invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_invoice(invoice_id, invoices, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param Invoices invoices: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Invoices
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_invoice_with_http_info(invoice_id, invoices, **kwargs)  # noqa: E501

    def update_invoice_with_http_info(self, invoice_id, invoices, **kwargs):  # noqa: E501
        """Allows you to update a specified sales invoices or purchase bills  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_invoice_with_http_info(invoice_id, invoices, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param Invoices invoices: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Invoices, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'invoices']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_invoice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `update_invoice`")  # noqa: E501
        # verify the required parameter 'invoices' is set
        if ('invoices' not in local_var_params or
                local_var_params['invoices'] is None):
            raise ApiValueError("Missing the required parameter `invoices` when calling `update_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invoices' in local_var_params:
            body_params = local_var_params['invoices']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Invoices',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_invoice_attachment_by_file_name(self, invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachment on invoices or purchase bills by it's filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_invoice_attachment_by_file_name(invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str file_name: Name of the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_invoice_attachment_by_file_name_with_http_info(invoice_id, file_name, body, **kwargs)  # noqa: E501

    def update_invoice_attachment_by_file_name_with_http_info(self, invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachment on invoices or purchase bills by it's filename  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_invoice_attachment_by_file_name_with_http_info(invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invoice_id: Unique identifier for an Invoice (required)
        :param str file_name: Name of the file you are attaching (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['invoice_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_invoice_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in local_var_params or
                local_var_params['invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `invoice_id` when calling `update_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_invoice_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in local_var_params:
            path_params['InvoiceID'] = local_var_params['invoice_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Invoices/{InvoiceID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_item(self, item_id, items, **kwargs):  # noqa: E501
        """Allows you to udpate a specified item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_item(item_id, items, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param Items items: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Items
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_item_with_http_info(item_id, items, **kwargs)  # noqa: E501

    def update_item_with_http_info(self, item_id, items, **kwargs):  # noqa: E501
        """Allows you to udpate a specified item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_item_with_http_info(item_id, items, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str item_id: Unique identifier for an Item (required)
        :param Items items: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Items, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['item_id', 'items']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_item" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'item_id' is set
        if ('item_id' not in local_var_params or
                local_var_params['item_id'] is None):
            raise ApiValueError("Missing the required parameter `item_id` when calling `update_item`")  # noqa: E501
        # verify the required parameter 'items' is set
        if ('items' not in local_var_params or
                local_var_params['items'] is None):
            raise ApiValueError("Missing the required parameter `items` when calling `update_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'item_id' in local_var_params:
            path_params['ItemID'] = local_var_params['item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'items' in local_var_params:
            body_params = local_var_params['items']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Items/{ItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Items',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_linked_transaction(self, linked_transaction_id, linked_transactions, **kwargs):  # noqa: E501
        """Allows you to update a specified linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_linked_transaction(linked_transaction_id, linked_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :param LinkedTransactions linked_transactions: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LinkedTransactions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_linked_transaction_with_http_info(linked_transaction_id, linked_transactions, **kwargs)  # noqa: E501

    def update_linked_transaction_with_http_info(self, linked_transaction_id, linked_transactions, **kwargs):  # noqa: E501
        """Allows you to update a specified linked transactions (billable expenses)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_linked_transaction_with_http_info(linked_transaction_id, linked_transactions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str linked_transaction_id: Unique identifier for a LinkedTransaction (required)
        :param LinkedTransactions linked_transactions: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LinkedTransactions, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['linked_transaction_id', 'linked_transactions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_linked_transaction" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'linked_transaction_id' is set
        if ('linked_transaction_id' not in local_var_params or
                local_var_params['linked_transaction_id'] is None):
            raise ApiValueError("Missing the required parameter `linked_transaction_id` when calling `update_linked_transaction`")  # noqa: E501
        # verify the required parameter 'linked_transactions' is set
        if ('linked_transactions' not in local_var_params or
                local_var_params['linked_transactions'] is None):
            raise ApiValueError("Missing the required parameter `linked_transactions` when calling `update_linked_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'linked_transaction_id' in local_var_params:
            path_params['LinkedTransactionID'] = local_var_params['linked_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'linked_transactions' in local_var_params:
            body_params = local_var_params['linked_transactions']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/LinkedTransactions/{LinkedTransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LinkedTransactions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_manual_journal(self, manual_journal_id, manual_journals, **kwargs):  # noqa: E501
        """Allows you to update a specified manual journal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_manual_journal(manual_journal_id, manual_journals, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param ManualJournals manual_journals: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ManualJournals
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_manual_journal_with_http_info(manual_journal_id, manual_journals, **kwargs)  # noqa: E501

    def update_manual_journal_with_http_info(self, manual_journal_id, manual_journals, **kwargs):  # noqa: E501
        """Allows you to update a specified manual journal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_manual_journal_with_http_info(manual_journal_id, manual_journals, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param ManualJournals manual_journals: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ManualJournals, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id', 'manual_journals']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_manual_journal" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `update_manual_journal`")  # noqa: E501
        # verify the required parameter 'manual_journals' is set
        if ('manual_journals' not in local_var_params or
                local_var_params['manual_journals'] is None):
            raise ApiValueError("Missing the required parameter `manual_journals` when calling `update_manual_journal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'manual_journals' in local_var_params:
            body_params = local_var_params['manual_journals']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManualJournals',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_manual_journal_attachment_by_file_name(self, manual_journal_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update a specified Attachment on ManualJournal by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_manual_journal_attachment_by_file_name(manual_journal_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str file_name: The name of the file being attached to a ManualJournal (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_manual_journal_attachment_by_file_name_with_http_info(manual_journal_id, file_name, body, **kwargs)  # noqa: E501

    def update_manual_journal_attachment_by_file_name_with_http_info(self, manual_journal_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update a specified Attachment on ManualJournal by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_manual_journal_attachment_by_file_name_with_http_info(manual_journal_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str manual_journal_id: Unique identifier for a ManualJournal (required)
        :param str file_name: The name of the file being attached to a ManualJournal (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['manual_journal_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_manual_journal_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'manual_journal_id' is set
        if ('manual_journal_id' not in local_var_params or
                local_var_params['manual_journal_id'] is None):
            raise ApiValueError("Missing the required parameter `manual_journal_id` when calling `update_manual_journal_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_manual_journal_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_manual_journal_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manual_journal_id' in local_var_params:
            path_params['ManualJournalID'] = local_var_params['manual_journal_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ManualJournals/{ManualJournalID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_purchase_order(self, purchase_order_id, purchase_orders, **kwargs):  # noqa: E501
        """Allows you to update a specified purchase order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_purchase_order(purchase_order_id, purchase_orders, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param PurchaseOrders purchase_orders: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PurchaseOrders
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_purchase_order_with_http_info(purchase_order_id, purchase_orders, **kwargs)  # noqa: E501

    def update_purchase_order_with_http_info(self, purchase_order_id, purchase_orders, **kwargs):  # noqa: E501
        """Allows you to update a specified purchase order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_purchase_order_with_http_info(purchase_order_id, purchase_orders, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str purchase_order_id: Unique identifier for a PurchaseOrder (required)
        :param PurchaseOrders purchase_orders: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PurchaseOrders, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['purchase_order_id', 'purchase_orders']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_purchase_order" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'purchase_order_id' is set
        if ('purchase_order_id' not in local_var_params or
                local_var_params['purchase_order_id'] is None):
            raise ApiValueError("Missing the required parameter `purchase_order_id` when calling `update_purchase_order`")  # noqa: E501
        # verify the required parameter 'purchase_orders' is set
        if ('purchase_orders' not in local_var_params or
                local_var_params['purchase_orders'] is None):
            raise ApiValueError("Missing the required parameter `purchase_orders` when calling `update_purchase_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'purchase_order_id' in local_var_params:
            path_params['PurchaseOrderID'] = local_var_params['purchase_order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'purchase_orders' in local_var_params:
            body_params = local_var_params['purchase_orders']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/PurchaseOrders/{PurchaseOrderID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PurchaseOrders',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_receipt(self, receipt_id, receipts, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified draft expense claim receipts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_receipt(receipt_id, receipts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param Receipts receipts: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Receipts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_receipt_with_http_info(receipt_id, receipts, **kwargs)  # noqa: E501

    def update_receipt_with_http_info(self, receipt_id, receipts, **kwargs):  # noqa: E501
        """Allows you to retrieve a specified draft expense claim receipts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_receipt_with_http_info(receipt_id, receipts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param Receipts receipts: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Receipts, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id', 'receipts']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_receipt" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `update_receipt`")  # noqa: E501
        # verify the required parameter 'receipts' is set
        if ('receipts' not in local_var_params or
                local_var_params['receipts'] is None):
            raise ApiValueError("Missing the required parameter `receipts` when calling `update_receipt`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'receipts' in local_var_params:
            body_params = local_var_params['receipts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Receipts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_receipt_attachment_by_file_name(self, receipt_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachment on expense claim receipts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_receipt_attachment_by_file_name(receipt_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str file_name: The name of the file being attached to the Receipt (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_receipt_attachment_by_file_name_with_http_info(receipt_id, file_name, body, **kwargs)  # noqa: E501

    def update_receipt_attachment_by_file_name_with_http_info(self, receipt_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update Attachment on expense claim receipts by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_receipt_attachment_by_file_name_with_http_info(receipt_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str receipt_id: Unique identifier for a Receipt (required)
        :param str file_name: The name of the file being attached to the Receipt (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['receipt_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_receipt_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'receipt_id' is set
        if ('receipt_id' not in local_var_params or
                local_var_params['receipt_id'] is None):
            raise ApiValueError("Missing the required parameter `receipt_id` when calling `update_receipt_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_receipt_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_receipt_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receipt_id' in local_var_params:
            path_params['ReceiptID'] = local_var_params['receipt_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Receipts/{ReceiptID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_repeating_invoice_attachment_by_file_name(self, repeating_invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update specified attachment on repeating invoices by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repeating_invoice_attachment_by_file_name(repeating_invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str file_name: The name of the file being attached to a Repeating Invoice (required)
        :param str body: Byte array of file in body of request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attachments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_repeating_invoice_attachment_by_file_name_with_http_info(repeating_invoice_id, file_name, body, **kwargs)  # noqa: E501

    def update_repeating_invoice_attachment_by_file_name_with_http_info(self, repeating_invoice_id, file_name, body, **kwargs):  # noqa: E501
        """Allows you to update specified attachment on repeating invoices by file name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repeating_invoice_attachment_by_file_name_with_http_info(repeating_invoice_id, file_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str repeating_invoice_id: Unique identifier for a Repeating Invoice (required)
        :param str file_name: The name of the file being attached to a Repeating Invoice (required)
        :param str body: Byte array of file in body of request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attachments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['repeating_invoice_id', 'file_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repeating_invoice_attachment_by_file_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'repeating_invoice_id' is set
        if ('repeating_invoice_id' not in local_var_params or
                local_var_params['repeating_invoice_id'] is None):
            raise ApiValueError("Missing the required parameter `repeating_invoice_id` when calling `update_repeating_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in local_var_params or
                local_var_params['file_name'] is None):
            raise ApiValueError("Missing the required parameter `file_name` when calling `update_repeating_invoice_attachment_by_file_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_repeating_invoice_attachment_by_file_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repeating_invoice_id' in local_var_params:
            path_params['RepeatingInvoiceID'] = local_var_params['repeating_invoice_id']  # noqa: E501
        if 'file_name' in local_var_params:
            path_params['FileName'] = local_var_params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attachments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tax_rate(self, tax_rates, **kwargs):  # noqa: E501
        """Allows you to update Tax Rates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tax_rate(tax_rates, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TaxRates tax_rates: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaxRates
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_tax_rate_with_http_info(tax_rates, **kwargs)  # noqa: E501

    def update_tax_rate_with_http_info(self, tax_rates, **kwargs):  # noqa: E501
        """Allows you to update Tax Rates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tax_rate_with_http_info(tax_rates, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TaxRates tax_rates: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaxRates, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tax_rates']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tax_rate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tax_rates' is set
        if ('tax_rates' not in local_var_params or
                local_var_params['tax_rates'] is None):
            raise ApiValueError("Missing the required parameter `tax_rates` when calling `update_tax_rate`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tax_rates' in local_var_params:
            body_params = local_var_params['tax_rates']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TaxRates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaxRates',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tracking_category(self, tracking_category_id, tracking_category, **kwargs):  # noqa: E501
        """Allows you to update tracking categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tracking_category(tracking_category_id, tracking_category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param TrackingCategory tracking_category: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrackingCategories
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_tracking_category_with_http_info(tracking_category_id, tracking_category, **kwargs)  # noqa: E501

    def update_tracking_category_with_http_info(self, tracking_category_id, tracking_category, **kwargs):  # noqa: E501
        """Allows you to update tracking categories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tracking_category_with_http_info(tracking_category_id, tracking_category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tracking_category_id: Unique identifier for a TrackingCategory (required)
        :param TrackingCategory tracking_category: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrackingCategories, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tracking_category_id', 'tracking_category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tracking_category" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tracking_category_id' is set
        if ('tracking_category_id' not in local_var_params or
                local_var_params['tracking_category_id'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category_id` when calling `update_tracking_category`")  # noqa: E501
        # verify the required parameter 'tracking_category' is set
        if ('tracking_category' not in local_var_params or
                local_var_params['tracking_category'] is None):
            raise ApiValueError("Missing the required parameter `tracking_category` when calling `update_tracking_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tracking_category_id' in local_var_params:
            path_params['TrackingCategoryID'] = local_var_params['tracking_category_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tracking_category' in local_var_params:
            body_params = local_var_params['tracking_category']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/TrackingCategories/{TrackingCategoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrackingCategories',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
